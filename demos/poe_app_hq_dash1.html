<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calibrating Trust in an LLM Energy Advisor</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-scale-logarithmic"></script>
    <style>
        :root {
            /* Light mode colors */
            --primary-color: #5D5CDE;
            --secondary-color: #2ecc71;
            --accent-color: #e74c3c;
            --text-color: #2c3e50;
            --light-bg: #f8f9fa;
            --dark-bg: #181818;
            --tab-active: #5D5CDE;
            --tab-inactive: #78a8c7;
            --border-color: #ddd;
            --gradient-start: #2c3e50;
            --gradient-end: #4ca1af;
            --card-bg: #ffffff;
            --chart-grid: rgba(0, 0, 0, 0.1);
            --insight-bg: #f9f9f9;
            --insight-border: #9b59b6;
            --research-bg: #eef5fd;
            --research-border: var(--primary-color);
            --simulation-bg: #ffffff;
            --advice-bg-high: #eafaf1;
            --advice-border-high: #2ecc71;
            --advice-bg-medium: #fef9e7;
            --advice-border-medium: #f39c12;
            --advice-bg-low: #fdedeb;
            --advice-border-low: #e74c3c;
            --results-bg: #f8f9fa;
            --correct-color: #2ecc71;
            --incorrect-color: #e74c3c;
            --table-header-bg: #f2f6f9;
            --table-row-even: #f9f9f9;
            --table-border: #e0e0e0;
            --panel-bg: #f5f7fa;
            --switch-bg: #ccc;
            --switch-bg-checked: #5D5CDE;
        }
        
        .dark {
            /* Dark mode colors */
            --primary-color: #6E6CFF;
            --secondary-color: #3eda85;
            --accent-color: #f76354;
            --text-color: #e0e0e0;
            --light-bg: #181818;
            --tab-active: #6E6CFF;
            --tab-inactive: #a0a0a0;
            --border-color: #444;
            --gradient-start: #121212;
            --gradient-end: #2c3e50;
            --card-bg: #222222;
            --chart-grid: rgba(255, 255, 255, 0.1);
            --insight-bg: #2a2a2a;
            --insight-border: #9b59b6;
            --research-bg: #2a2a40;
            --research-border: var(--primary-color);
            --simulation-bg: #222222;
            --advice-bg-high: #1a332a;
            --advice-border-high: #2ecc71;
            --advice-bg-medium: #332e1a;
            --advice-border-medium: #f39c12;
            --advice-bg-low: #331a1a;
            --advice-border-low: #e74c3c;
            --results-bg: #2a2a2a;
            --correct-color: #2ecc71;
            --incorrect-color: #e74c3c;
            --table-header-bg: #333;
            --table-row-even: #2a2a2a;
            --table-border: #444;
            --panel-bg: #252525;
            --switch-bg: #444;
            --switch-bg-checked: #6E6CFF;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            max-width: 1200px;
            margin: 0 auto;
            padding: 0;
            background-color: var(--light-bg);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .header {
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            color: white;
            padding: 30px 20px;
            border-radius: 0 0 10px 10px;
            margin-bottom: 20px;
            text-align: center;
            position: relative;
        }
        
        .theme-switch-wrapper {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        
        .theme-switch {
            display: inline-block;
            height: 26px;
            position: relative;
            width: 50px;
        }
        
        .theme-switch input {
            display: none;
        }
        
        .slider {
            background-color: var(--switch-bg);
            bottom: 0;
            cursor: pointer;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            transition: .4s;
            border-radius: 34px;
        }
        
        .slider:before {
            background-color: white;
            bottom: 4px;
            content: "";
            height: 18px;
            left: 4px;
            position: absolute;
            transition: .4s;
            width: 18px;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: var(--switch-bg-checked);
        }
        
        input:checked + .slider:before {
            transform: translateX(24px);
        }
        
        .theme-icon {
            color: white;
            margin-right: 8px;
            font-size: 20px;
        }
        
        .header h1 {
            margin: 0;
            font-size: 32px;
        }
        
        .header p {
            margin: 10px 0 0;
            font-size: 18px;
            opacity: 0.9;
        }
        
        .tab-container {
            margin: 0 20px;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 0;
            padding-left: 0;
            list-style: none;
            border-bottom: 2px solid var(--border-color);
            overflow-x: auto;
            white-space: nowrap;
        }
        
        .tabs li {
            margin-right: 5px;
        }
        
        .tabs li a {
            display: block;
            padding: 12px 20px;
            text-decoration: none;
            color: var(--tab-inactive);
            border-radius: 5px 5px 0 0;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .tabs li a:hover {
            background-color: rgba(93, 92, 222, 0.1);
            color: var(--tab-active);
        }
        
        .tabs li a.active {
            color: var(--tab-active);
            border-bottom: 3px solid var(--tab-active);
            background-color: var(--card-bg);
        }
        
        .tab-content {
            background-color: var(--card-bg);
            border-radius: 0 0 10px 10px;
            padding: 25px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            min-height: 500px;
        }
        
        .tab-pane {
            display: none;
        }
        
        .tab-pane.active {
            display: block;
        }
        
        h2, h3 {
            color: var(--text-color);
        }
        
        h2 {
            font-size: 24px;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .section {
            margin-bottom: 30px;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
            margin: 25px 0;
            background-color: var(--card-bg);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .flex-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .flex-item {
            flex: 1;
            min-width: 300px;
        }
        
        .control-panel {
            background-color: var(--panel-bg);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }
        
        .slider-container {
            margin-bottom: 20px;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-color);
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            background: var(--border-color);
            border-radius: 5px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }
        
        .slider-value {
            display: inline-block;
            min-width: 45px;
            text-align: right;
            margin-left: 10px;
            font-weight: bold;
        }
        
        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 14px;
        }
        
        .btn:hover {
            background-color: #4b4ab2;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .simulation-area {
            background-color: var(--simulation-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 25px;
            margin-top: 20px;
        }
        
        .appliance-info {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .appliance-icon {
            width: 60px;
            height: 60px;
            margin-right: 20px;
            background-color: rgba(93, 92, 222, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
        }
        
        .advice-box {
            border-left: 4px solid var(--primary-color);
            padding: 15px 20px;
            background-color: rgba(93, 92, 222, 0.1);
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .advice-high {
            border-left-color: var(--advice-border-high);
            background-color: var(--advice-bg-high);
        }
        
        .advice-medium {
            border-left-color: var(--advice-border-medium);
            background-color: var(--advice-bg-medium);
        }
        
        .advice-low {
            border-left-color: var(--advice-border-low);
            background-color: var(--advice-bg-low);
        }
        
        .user-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 25px;
        }
        
        .confidence-slider-container {
            margin: 15px 0;
        }
        
        .confidence-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 13px;
            color: var(--text-color);
            opacity: 0.8;
        }
        
        .decision-btns {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        
        .decision-btns .btn {
            flex: 1;
        }
        
        .user-btn {
            background-color: #3498db;
        }
        
        .ai-btn {
            background-color: #9b59b6;
        }
        
        .results-display {
            margin-top: 25px;
            padding: 20px;
            background-color: var(--results-bg);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 14px;
        }
        
        table, th, td {
            border: 1px solid var(--table-border);
        }
        
        th, td {
            padding: 10px 15px;
            text-align: left;
        }
        
        th {
            background-color: var(--table-header-bg);
            font-weight: 600;
        }
        
        tr:nth-child(even) {
            background-color: var(--table-row-even);
        }
        
        .correct {
            color: var(--correct-color);
            font-weight: bold;
        }
        
        .incorrect {
            color: var(--incorrect-color);
        }
        
        .research-question {
            background-color: var(--research-bg);
            border-left: 4px solid var(--research-border);
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .methods-diagram {
            max-width: 100%;
            height: auto;
            margin: 20px 0;
        }
        
        .insight-box {
            background-color: var(--insight-bg);
            border-left: 4px solid var(--insight-border);
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .paper-citation {
            background-color: var(--research-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .paper-citation h3 {
            margin-top: 0;
            font-size: 18px;
        }
        
        .paper-citation p {
            margin-bottom: 10px;
        }
        
        .paper-citation .authors {
            font-style: italic;
            color: var(--text-color);
            opacity: 0.8;
        }
        
        .measures-table {
            width: 100%;
            margin-bottom: 20px;
        }
        
        .measures-table th {
            background-color: var(--research-bg);
        }
        
        .hypothesis {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .hypothesis h4 {
            color: var(--primary-color);
            margin-bottom: 8px;
        }
        
        .variables-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
        }
        
        .variable-pill {
            background-color: rgba(93, 92, 222, 0.1);
            border-radius: 15px;
            padding: 5px 12px;
            font-size: 14px;
            display: inline-block;
        }
        
        .iv-pill {
            background-color: #e1f5fe;
            border: 1px solid #81d4fa;
        }
        
        .dark .iv-pill {
            background-color: #1a2a35;
            border: 1px solid #2c5a7c;
        }
        
        .dv-pill {
            background-color: #e8f5e9;
            border: 1px solid #a5d6a7;
        }
        
        .dark .dv-pill {
            background-color: #1a351c;
            border: 1px solid #2c7c34;
        }
        
        .mod-pill {
            background-color: #fff3e0;
            border: 1px solid #ffcc80;
        }
        
        .dark .mod-pill {
            background-color: #352b1a;
            border: 1px solid #7c602c;
        }
        
        .phase-box {
            background-color: var(--insight-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .phase-box h4 {
            color: var(--text-color);
            margin-top: 0;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }
        
        .prediction-chart {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .prediction-chart h3 {
            margin-top: 0;
            color: var(--text-color);
            font-size: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .prediction-chart p {
            color: var(--text-color);
            opacity: 0.9;
            margin-bottom: 20px;
        }
        
        .hypothesis-summary {
            font-weight: bold;
            color: var(--text-color);
            margin-top: 15px;
        }
        
        .llm-diagram {
            max-width: 100%;
            height: auto;
            margin: 30px 0;
            overflow-x: auto;
            text-align: center;
        }
        
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .dashboard-card {
            background-color: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            border: 1px solid var(--border-color);
            height: 300px;
            display: flex;
            flex-direction: column;
        }
        
        .dashboard-card h3 {
            margin-top: 0;
            font-size: 18px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .dashboard-card p {
            color: var(--text-color);
            opacity: 0.9;
        }
        
        .dashboard-card .chart-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding-bottom: 10px;
        }
        
        .stat-number {
            font-size: 36px;
            font-weight: bold;
            color: var(--primary-color);
            text-align: center;
            margin: 10px 0;
        }
        
        .stat-label {
            text-align: center;
            font-size: 14px;
            color: var(--text-color);
            opacity: 0.8;
        }
        
        .progress-bar-container {
            height: 10px;
            background-color: var(--border-color);
            border-radius: 5px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 5px;
            transition: width 0.5s ease;
        }

        .dashboard-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        
        .dashboard-status {
            font-size: 14px;
            background-color: var(--primary-color);
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            display: inline-block;
        }
        
        .dashboard-status.active {
            background-color: #2ecc71;
        }
        
        .dashboard-status.error {
            background-color: #e74c3c;
        }
        
        .dashboard-status.inactive {
            background-color: #95a5a6;
        }
        
        .live-badge {
            display: inline-block;
            background-color: #e74c3c;
            color: white;
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: 10px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        @media (max-width: 768px) {
            .tabs li a {
                padding: 10px 15px;
                font-size: 14px;
            }
            
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
            
            .dashboard-card {
                height: auto;
                min-height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="theme-switch-wrapper">
            <span class="theme-icon">☀️</span>
            <label class="theme-switch" for="checkbox">
                <input type="checkbox" id="checkbox">
                <div class="slider"></div>
            </label>
        </div>
        <h1>Calibrating Trust in an LLM Energy Advisor</h1>
        <p>The Impact of Linguistic Uncertainty on User Trust and Decision Making</p>
    </div>
    
    <div class="tab-container">
        <ul class="tabs">
            <li><a href="#overview" class="active">Overview</a></li>
            <li><a href="#energy">Energy Perception</a></li>
            <li><a href="#ai-confidence">AI Confidence</a></li>
            <li><a href="#llm-advisor">LLM Energy Advisor</a></li>
            <li><a href="#dashboard">Live Dashboard</a></li>
            <li><a href="#experimental-design">Experimental Design</a></li>
            <li><a href="#individual-differences">Individual Differences</a></li>
            <li><a href="#predictions">Predictions</a></li>
            <li><a href="#terminology">Terminology</a></li>
        </ul>
        
        <div class="tab-content">
            <!-- Overview Tab -->
            <div id="overview" class="tab-pane active">
                <h2>Understanding Human-AI Trust in Energy Decision Making</h2>
                
                <div class="research-question">
                    <p><strong>Research Question:</strong> "Given that people often misunderstand energy consumption (Attari), how will they react when an LLM energy advisor gives them advice, especially when we deliberately make that AI express different levels of linguistic certainty (inspired by Steyvers)?"</p>
                </div>
                
                <div class="flex-container">
                    <div class="flex-item">
                        <h3>The Problem: Energy Misconceptions</h3>
                        <p>Attari et al. (2010) demonstrated that people systematically:</p>
                        <ul>
                            <li><strong style="color:#e74c3c">Underestimate</strong> the energy used by high-consumption appliances (like air conditioners)</li>
                            <li><strong style="color:#2ecc71">Overestimate</strong> the energy used by low-consumption ones (like light bulbs)</li>
                            <li>Focus on less effective <strong>"curtailment"</strong> actions rather than more impactful <strong>"efficiency"</strong> improvements</li>
                        </ul>
                    </div>
                    <div class="flex-item">
                        <h3>The Challenge: AI Trust Calibration</h3>
                        <p>Steyvers et al. (2025) showed that:</p>
                        <ul>
                            <li>A <strong>"calibration gap"</strong> exists between an LLM's internal confidence and human perception</li>
                            <li>Users typically <strong style="color:#e74c3c">overestimate</strong> LLM accuracy, especially with longer or confident-sounding explanations</li>
                            <li>Using <strong>appropriate hedging language</strong> when confidence is low helps narrow this gap</li>
                        </ul>
                    </div>
                </div>
                
                <div class="section">
                    <h3>Research Questions</h3>
                    
                    <div class="hypothesis">
                        <h4>RQ1: Reliance &amp; Accuracy Discrimination</h4>
                        <p>How does the LLM's linguistic expression of uncertainty influence participants' reliance on its energy estimates when forced to choose between the AI's estimate and their own prior estimate? Specifically, does appropriately hedged language from the AI improve participants' ability to discriminate between correct and incorrect AI advice?</p>
                    </div>
                    
                    <div class="hypothesis">
                        <h4>RQ2: Subjective Confidence &amp; Trust</h4>
                        <p>How does the LLM's linguistic expression of uncertainty affect participants' subjective confidence in the AI's specific estimate for each item, and their overall post-task trust in the LLM advisor?</p>
                    </div>
                    
                    <div class="hypothesis">
                        <h4>RQ3: Calibration of Confidence</h4>
                        <p>Does aligning the LLM's linguistic expression of uncertainty with its (simulated) internal confidence lead to better calibration between participants' confidence in the AI's estimates and the actual accuracy of those estimates?</p>
                    </div>
                    
                    <div class="hypothesis">
                        <h4>RQ4: Role of Prior Knowledge &amp; Individual Differences</h4>
                        <p>How do participants' baseline energy knowledge accuracy and individual differences (e.g., AI literacy, numeracy) moderate the effects of the LLM's expressed uncertainty on their reliance, confidence, discrimination, and calibration?</p>
                    </div>
                </div>
                
                <div class="section">
                    <h3>Hypotheses</h3>
                    
                    <div class="hypothesis">
                        <h4>H1: Appropriate Reliance &amp; Discrimination</h4>
                        <p><strong>H1a (Reliance Shift):</strong> Participants will be less likely to choose the AI's estimate when it is expressed with hedged language compared to confident language.</p>
                        <p><strong>H1b (Improved Discrimination):</strong> The reduction in reliance due to hedged language will be significantly greater when the AI's advice is incorrect than when it is correct, manifesting as improved discrimination when uncertainty cues are calibrated.</p>
                    </div>
                    
                    <div class="hypothesis">
                        <h4>H2: Subjective Confidence &amp; Trust</h4>
                        <p><strong>H2a (Item-Level Confidence):</strong> Participants will report lower confidence in the AI's estimate when its explanation is hedged compared to when it is confident.</p>
                        <p><strong>H2b (Overall Trust):</strong> Overall post-task trust might be more nuanced: it could be lower with consistent hedging, or, ideally, better calibrated in the calibrated uncertainty condition.</p>
                    </div>
                    
                    <div class="hypothesis">
                        <h4>H3: Improved Metacognitive Calibration</h4>
                        <p>Participants exposed to AI estimates with calibrated linguistic uncertainty cues will exhibit better metacognitive calibration compared to participants exposed only to confidently expressed AI estimates.</p>
                    </div>
                    
                    <div class="hypothesis">
                        <h4>H4: Moderation by Individual Differences</h4>
                        <p><strong>H4a (Prior Knowledge):</strong> Participants with more accurate baseline energy knowledge will demonstrate more appropriate reliance and better calibration overall. The benefits of calibrated AI uncertainty cues might be more pronounced for those with initially poorer knowledge.</p>
                        <p><strong>H4b (AI Literacy/Numeracy):</strong> Participants with higher AI literacy and numeracy will be more sensitive to the AI's linguistic uncertainty cues, leading to more pronounced effects on appropriate reliance and better calibration.</p>
                    </div>
                </div>
            </div>
            
            <!-- Energy Perception Tab -->
            <div id="energy" class="tab-pane">
                <h2>Energy Perception: Systematic Misconceptions</h2>
                
                <div class="paper-citation">
                    <h3>Attari et al. (2010): Public Perceptions of Energy Consumption and Savings</h3>
                    <p class="authors">Shahzeen Z. Attari, Michael L. DeKay, Cliff I. Davidson, Wändi Bruine de Bruin</p>
                    <p>This seminal study demonstrated that Americans systematically underestimate energy use for high-energy activities and overestimate it for low-energy activities, creating a "compression" effect in energy perceptions.</p>
                    <p>The research also found that people tend to focus on curtailment (turning off, using less) rather than efficiency improvements (using better technology), despite the latter often having greater energy-saving potential.</p>
                </div>
                
                <div class="chart-container">
                    <canvas id="energyPerceptionChart"></canvas>
                </div>
                
                <div class="control-panel">
                    <div class="slider-container">
                        <label for="underestimationFactor">High-Energy Appliance Underestimation Factor: <span id="underestimationValue" class="slider-value">2.8</span>x</label>
                        <input type="range" id="underestimationFactor" min="1" max="5" step="0.1" value="2.8">
                    </div>
                    <div class="slider-container">
                        <label for="overestimationFactor">Low-Energy Appliance Overestimation Factor: <span id="overestimationValue" class="slider-value">1.6</span>x</label>
                        <input type="range" id="overestimationFactor" min="1" max="3" step="0.1" value="1.6">
                    </div>
                    <button id="updateEnergyChart" class="btn">Update Perception Model</button>
                </div>
                
                <div class="section">
                    <h3>Key Findings from Attari et al. (2010)</h3>
                    
                    <div class="flex-container">
                        <div class="flex-item">
                            <h4>Perception Biases</h4>
                            <ul>
                                <li>Underestimation for high-energy items (~2.8x factor)</li>
                                <li>Overestimation for low-energy items (~1.6x factor)</li>
                                <li>Creates a "compressed" mental model of energy differences</li>
                                <li>People with higher numeracy showed somewhat more accurate perceptions</li>
                            </ul>
                        </div>
                        <div class="flex-item">
                            <h4>Energy Saving Misconceptions</h4>
                            <ul>
                                <li>People focus on curtailment actions (e.g., turning off lights)</li>
                                <li>Efficiency improvements (e.g., better appliances) are undervalued</li>
                                <li>This misalignment can lead to suboptimal conservation choices</li>
                                <li>Policy implications: need for better communication of relative impacts</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="insight-box">
                        <p><strong>Implications for our study:</strong> If people already have systematically inaccurate beliefs about energy consumption, how will this affect their interactions with an AI energy advisor? Will they trust incorrect AI advice that aligns with their own misconceptions? Can linguistic uncertainty cues help overcome these biases?</p>
                    </div>
                </div>
            </div>
            
            <!-- AI Confidence Tab -->
            <div id="ai-confidence" class="tab-pane">
                <h2>AI Confidence: The Calibration Gap</h2>
                
                <div class="paper-citation">
                    <h3>Steyvers et al. (2025): Calibrating Trust in Large Language Models</h3>
                    <p class="authors">Mark Steyvers, Ananya Kumar, Pang Wei Koh, Pulkit Agrawal et al.</p>
                    <p>This forward-looking work identified a significant "calibration gap" between an LLM's internal confidence (based on token probabilities) and human perception of its accuracy. The research demonstrated that manipulating the linguistic expression of uncertainty can help narrow this gap.</p>
                </div>
                
                <!-- LLM Internal State Diagram -->
                <div class="section">
                    <h3>LLM Internal State and Trust Calibration Process</h3>
                    <p>Understanding how LLM confidence translates to linguistic outputs and influences human trust:</p>
                    
                    <div id="llmInternalDiagram" class="llm-diagram">
                        <!-- SVG diagram will be injected here by JavaScript -->
                    </div>
                </div>
                
                <div class="chart-container">
                    <canvas id="calibrationGapChart"></canvas>
                </div>
                
                <div class="control-panel">
                    <div class="slider-container">
                        <label for="calibrationGapSize">Calibration Gap Size: <span id="calibrationGapValue" class="slider-value">20</span>%</label>
                        <input type="range" id="calibrationGapSize" min="0" max="50" step="5" value="20">
                    </div>
                    <div class="slider-container">
                        <label for="hedgingEffect">Effect of Hedging Language: <span id="hedgingEffectValue" class="slider-value">15</span>% reduction</label>
                        <input type="range" id="hedgingEffect" min="0" max="30" step="5" value="15">
                    </div>
                    <button id="updateCalibrationChart" class="btn">Update Calibration Model</button>
                </div>
                
                <div class="section">
                    <h3>Key Findings from Steyvers et al. (2025)</h3>
                    
                    <div class="flex-container">
                        <div class="flex-item">
                            <h4>The Calibration Gap</h4>
                            <ul>
                                <li>LLMs have internal confidence indicators (token probabilities)</li>
                                <li>Users systematically overestimate LLM accuracy</li>
                                <li>This gap is larger with confident-sounding or longer explanations</li>
                                <li>Result: inappropriate reliance on AI advice</li>
                            </ul>
                        </div>
                        <div class="flex-item">
                            <h4>Bridging the Gap with Linguistic Uncertainty</h4>
                            <ul>
                                <li>Hedging language can signal LLM uncertainty</li>
                                <li>Examples: "I think," "probably," "might be," etc.</li>
                                <li>When calibrated with actual LLM confidence, hedging improves trust calibration</li>
                                <li>Users can better discriminate between reliable and unreliable advice</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="insight-box">
                        <p><strong>Implications for our study:</strong> By applying the linguistic uncertainty techniques from Steyvers et al. to the domain of energy advice, we can test whether these approaches help users overcome both the AI overconfidence problem and their own energy misconceptions.</p>
                    </div>
                </div>
                
                <div class="section">
                    <h3>Examples of Linguistic Uncertainty Expressions</h3>
                    
                    <table>
                        <tbody><tr>
                            <th>Confidence Level</th>
                            <th>Linguistic Expression</th>
                            <th>Example</th>
                        </tr>
                        <tr>
                            <td><strong>High Confidence</strong></td>
                            <td>Assertive, direct statements</td>
                            <td>"A central AC unit uses 3500 units of energy per hour. This is because AC systems require significant power to cool air through the compression cycle."</td>
                        </tr>
                        <tr>
                            <td><strong>Medium Confidence</strong></td>
                            <td>Qualified assertions, some hedges</td>
                            <td>"A central AC unit typically uses around 3500 units of energy per hour. This is generally because most residential AC systems need substantial power for cooling, though exact usage can vary by model."</td>
                        </tr>
                        <tr>
                            <td><strong>Low Confidence</strong></td>
                            <td>Multiple hedges, alternatives presented</td>
                            <td>"I think a central AC might use approximately 3500 units of energy per hour, but I'm not entirely certain. Different AC systems can vary considerably, possibly ranging from 2000 to 5000 units depending on size, efficiency, and operating conditions."</td>
                        </tr>
                    </tbody></table>
                </div>
            </div>
            
            <!-- LLM Energy Advisor Tab -->
            <div id="llm-advisor" class="tab-pane">
                <h2>Interactive Simulation: LLM Energy Advisor</h2>
                <p>This simulation allows you to experience how different expressions of uncertainty affect trust in an LLM's energy advice:</p>
                
                <div class="control-panel">
                    <div class="slider-container">
                        <label for="uncertaintyLevel">LLM Uncertainty Expression Style:</label>
                        <select id="uncertaintyLevel" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid var(--border-color); background-color: var(--card-bg); color: var(--text-color);">
                            <option value="0">Always Confident Language</option>
                            <option value="1" selected="">Calibrated Uncertainty (Hedge When Uncertain)</option>
                        </select>
                    </div>
                    <div class="slider-container">
                        <label for="userKnowledgeLevel">User Energy Knowledge Level: <span id="userKnowledgeValue" class="slider-value">Medium</span></label>
                        <input type="range" id="userKnowledgeLevel" min="0" max="2" step="1" value="1">
                    </div>
                    <div class="slider-container">
                        <label for="aiAccuracy">AI Advice Accuracy: <span id="aiAccuracyValue" class="slider-value">70</span>%</label>
                        <input type="range" id="aiAccuracy" min="40" max="100" step="5" value="70">
                    </div>
                    <button id="startSimulation" class="btn">Start New Simulation</button>
                </div>
                
                <div class="simulation-area" id="simulationArea">
                    <p>Configure the parameters above and click "Start New Simulation" to begin the experiment.</p>
                </div>
                
                <div class="results-display" id="simulationResults" style="display: none;">
                    <h3>Simulation Results</h3>
                    <p>Complete the simulation to see your results.</p>
                </div>
                
                <div class="section">
                    <h3>Simulation Measures</h3>
                    
                    <div class="flex-container">
                        <div class="flex-item">
                            <h4>Primary Measures</h4>
                            <ul>
                                <li><strong>Appropriate Reliance:</strong> Choosing AI advice when it's correct, rejecting when incorrect</li>
                                <li><strong>Confidence Calibration:</strong> Alignment between confidence ratings and actual correctness</li>
                            </ul>
                        </div>
                        <div class="flex-item">
                            <h4>Scoring</h4>
                            <ul>
                                <li><strong>Brier Score/ECE:</strong> Discrepancy between confidence and accuracy (lower is better)</li>
                                <li><strong>AUC:</strong> Area under the ROC curve for discrimination (higher is better)</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Live Dashboard Tab (New) -->
            <div id="dashboard" class="tab-pane">
                <div class="dashboard-header">
                    <h2>Live Experiment Dashboard <span class="live-badge">LIVE</span></h2>
                    <div class="dashboard-status" id="dashboardStatus">Initializing...</div>
                </div>
                
                <div class="insight-box" style="margin-bottom: 20px;">
                    <p><strong>Dashboard Simulation:</strong> This interactive dashboard simulates the real-time data collection and visualization from our experiment. It shows how participants respond to AI energy advice based on their knowledge level and the AI's expression of uncertainty. The simulation randomly generates participant data based on our theoretical models, displaying key metrics like reliance rates, confidence distribution, and calibration error. Configure the update interval and press "Start Dashboard" to watch the experiment unfold through dynamic charts and auto-generated insights.</p>
                </div>
                
                <div class="control-panel">
                    <div class="slider-container">
                        <label for="dashSimulationMode">Simulation Mode:</label>
                        <select id="dashSimulationMode" style="width: 100%; padding: 8px; border-radius: 5px; border: 1px solid var(--border-color); background-color: var(--card-bg); color: var(--text-color);">
                            <option value="real">Real-time Data Collection</option>
                            <option value="simulated" selected="">Simulated Data Stream</option>
                        </select>
                    </div>
                    <div class="slider-container">
                        <label for="dashUpdateInterval">Data Update Interval: <span id="updateIntervalValue" class="slider-value">5</span> seconds</label>
                        <input type="range" id="dashUpdateInterval" min="1" max="10" step="1" value="5">
                    </div>
                    <div class="flex-container" style="margin: 0;">
                        <button id="startDashboard" class="btn" style="flex: 1;">Start Dashboard</button>
                        <button id="pauseDashboard" class="btn" style="flex: 1; background-color: #e67e22; display: none;">Pause</button>
                        <button id="resetDashboard" class="btn" style="flex: 1; background-color: #e74c3c; display: none;">Reset</button>
                    </div>
                </div>
                
                <div class="dashboard-grid">
                    <div class="dashboard-card">
                        <h3>Current Participant Count</h3>
                        <div class="chart-area">
                            <div>
                                <div class="stat-number" id="participantCount">0</div>
                                <div class="stat-label">participants</div>
                                <div class="progress-bar-container">
                                    <div class="progress-bar" id="participantProgress" style="width: 0%;"></div>
                                </div>
                                <div class="stat-label">Target: <span id="participantTarget">120</span></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="dashboard-card">
                        <h3>Condition Assignment</h3>
                        <div class="chart-area">
                            <canvas id="conditionsPieChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="dashboard-card">
                        <h3>User Reliance by Condition</h3>
                        <div class="chart-area">
                            <canvas id="relianceBarChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="dashboard-card">
                        <h3>Confidence Rating Distribution</h3>
                        <div class="chart-area">
                            <canvas id="confidenceHistogram"></canvas>
                        </div>
                    </div>
                    
                    <div class="dashboard-card">
                        <h3>Trust Calibration over Time</h3>
                        <div class="chart-area">
                            <canvas id="calibrationLineChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="dashboard-card">
                        <h3>Condition × Knowledge Interaction</h3>
                        <div class="chart-area">
                            <canvas id="knowledgeConditionChart"></canvas>
                        </div>
                    </div>
                </div>
                
                <div class="section" style="margin-top: 30px;">
                    <h3>Live Data Analysis</h3>
                    <div class="insight-box">
                        <h4>Current Insights:</h4>
                        <ul id="liveInsights">
                            <li>Experiment dashboard initializing...</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- Experimental Design Tab -->
            <div id="experimental-design" class="tab-pane">
                <h2>Experimental Design Methodology</h2>
                
                <div id="methodsDiagram" class="methods-diagram">
                    <!-- SVG diagram will be rendered here -->
                </div>
                
                <div class="section">
                    <h3>Study Design: Mixed-Factorial</h3>
                    
                    <div class="variables-list">
                        <div class="variable-pill iv-pill">IV1: AI Uncertainty Communication Style (Between-Subjects)</div>
                        <div class="variable-pill iv-pill">IV2: AI Advice Correctness (Within-Subjects)</div>
                        <div class="variable-pill dv-pill">DV1: User Reliance (Choice)</div>
                        <div class="variable-pill dv-pill">DV2: Confidence in AI Estimate</div>
                        <div class="variable-pill dv-pill">DV3: Trust Calibration</div>
                        <div class="variable-pill mod-pill">Moderator: User Energy Knowledge</div>
                        <div class="variable-pill mod-pill">Moderator: AI Literacy</div>
                        <div class="variable-pill mod-pill">Moderator: Numeracy</div>
                    </div>
                    
                    <div class="phase-box">
                        <h4>Phase 1: Baseline Energy Knowledge Assessment</h4>
                        <p>Participants estimate energy consumption of various appliances, establishing both their baseline knowledge and their own estimation biases.</p>
                        <p><strong>Task:</strong> "Relative to a 100-watt incandescent light bulb which uses 100 units of energy per hour, how many units of energy do you think the following device typically uses in one hour?"</p>
                        <p><strong>Measure:</strong> Accuracy of energy estimations compared to ground truth values</p>
                    </div>
                    
                    <div class="phase-box">
                        <h4>Phase 2: AI Energy Advisor Interaction</h4>
                        <p>Participants interact with an LLM providing energy estimates, with expressions of uncertainty manipulated based on condition.</p>
                        <p><strong>Between-Subjects Factor (Primary Manipulation):</strong></p>
                        <ul>
                            <li><strong>Calibrated Uncertainty:</strong> AI uses confident language for correct advice and hedged language for incorrect advice (with hedging level potentially based on error magnitude)</li>
                            <li><strong>Always Confident:</strong> AI always uses confident language for both correct and incorrect advice</li>
                        </ul>
                        <p><strong>Within-Subjects Factors:</strong></p>
                        <ul>
                            <li><strong>Item:</strong> 10-12 energy appliances/scenarios (counterbalanced order)</li>
                            <li><strong>AI Advice Correctness:</strong> (Correct, Incorrect - pre-determined and counterbalanced)</li>
                        </ul>
                        <p><strong>Measures:</strong></p>
                        <ul>
                            <li>Confidence in AI's estimate (0-100% slider)</li>
                            <li>Forced choice between own estimate and AI's estimate</li>
                        </ul>
                    </div>
                </div>
                
                <div class="section">
                    <h3>Procedure</h3>
                    <ol>
                        <li>Consent, Demographics, Individual Difference Measures (AI Literacy, Numeracy, Propensity to Trust Automation)</li>
                        <li>Phase 1: Baseline Energy Estimation task for all items</li>
                        <li>Instructions for Phase 2: Introduce AI advisor, explain tasks</li>
                        <li>Phase 2: Trial-by-trial interaction for each item:
                            <ul>
                                <li>Present AI estimate + explanation (tone per condition)</li>
                                <li>Participant rates confidence in AI estimate</li>
                                <li>Participant's Phase 1 estimate shown; participant makes forced choice</li>
                            </ul>
                        </li>
                        <li>Post-Task Measures: Overall Trust Scale, Manipulation Check, Open-ended feedback</li>
                        <li>Debriefing (no trial-by-trial feedback during the main task)</li>
                    </ol>
                </div>
                
                <div class="section">
                    <h3>Key Analyses</h3>
                    <ul>
                        <li>Mixed-effects models for reliance choices and confidence ratings</li>
                        <li>Calculation of Brier/ECE for calibration (H3)</li>
                        <li>Calculation of AUC for discrimination (H1b)</li>
                        <li>Moderation analyses for H4 (including interaction effects with individual differences)</li>
                    </ul>
                </div>
            </div>
            
            <!-- Individual Differences Tab -->
            <div id="individual-differences" class="tab-pane">
                <h2>Individual Differences as Moderators</h2>
                
                <div class="section">
                    <h3>Key Individual Difference Measures</h3>
                    
                    <div class="flex-container">
                        <div class="flex-item">
                            <h4>Energy Domain Knowledge</h4>
                            <p>Measured through Phase 1 energy estimation accuracy:</p>
                            <ul>
                                <li>Accuracy of initial energy estimates</li>
                                <li>Pattern of errors (underestimation vs. overestimation)</li>
                                <li>Self-reported familiarity with energy concepts</li>
                            </ul>
                            <p><strong>Hypothesis H4a:</strong> Higher energy knowledge will lead to better discrimination between correct and incorrect AI advice. The benefits of calibrated AI uncertainty cues may be more pronounced for those with initially poorer knowledge.</p>
                        </div>
                        <div class="flex-item">
                            <h4>AI Literacy</h4>
                            <p>Measured using established scales:</p>
                            <ul>
                                <li>AICOS-SV (AI Conceptual and Operational Skills)</li>
                                <li>Previous experience with LLMs</li>
                                <li>Understanding of AI capabilities and limitations</li>
                            </ul>
                            <p><strong>Hypothesis H4b:</strong> Higher AI literacy will lead to better interpretation of linguistic uncertainty cues and more appropriate reliance adjustments.</p>
                        </div>
                    </div>
                    
                    <div class="flex-container">
                        <div class="flex-item">
                            <h4>Numeracy</h4>
                            <p>Measured using Berlin Numeracy Test:</p>
                            <ul>
                                <li>Understanding of numerical concepts</li>
                                <li>Ability to interpret probabilities</li>
                                <li>Comfort with quantitative reasoning</li>
                            </ul>
                            <p><strong>Hypothesis H4b (continued):</strong> Higher numeracy will improve calibration between confidence ratings and actual accuracy, and enhance sensitivity to linguistic uncertainty cues.</p>
                        </div>
                        <div class="flex-item">
                            <h4>Trust Propensity</h4>
                            <p>Measured using Jian-Bisantz-Drury Trust Scale:</p>
                            <ul>
                                <li>General tendency to trust automation</li>
                                <li>Skepticism toward AI systems</li>
                                <li>Complacency potential</li>
                            </ul>
                            <p><strong>Additional Moderator:</strong> High trust propensity may moderate the effect of uncertainty expressions, potentially requiring stronger uncertainty signals.</p>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <canvas id="knowledgeInteractionChart"></canvas>
                </div>
                
                <div class="insight-box">
                    <h4>Key Hypothesized Interactions:</h4>
                    <ul>
                        <li><strong>Energy Knowledge × Uncertainty Expression:</strong> Users with medium energy knowledge may benefit most from calibrated uncertainty, as high-knowledge users already have good discrimination and low-knowledge users may lack the basis to evaluate advice.</li>
                        <li><strong>AI Literacy × Uncertainty Expression:</strong> High AI literacy users will show stronger effects of uncertainty cues, with better discrimination between confident and hedged advice.</li>
                        <li><strong>Numeracy × Calibration:</strong> Higher numeracy will correlate with better trust calibration overall, with smaller calibration errors for all conditions.</li>
                    </ul>
                </div>
            </div>
            
            <!-- Predictions Tab -->
            <div id="predictions" class="tab-pane">
                <h2>Empirical Predictions</h2>
                <p>Based on our theoretical framework and hypotheses, we can make specific empirical predictions about the expected patterns of results.</p>
                
                <div class="prediction-chart">
                    <h3>H1: Impact of Linguistic Uncertainty on Reliance by AI Correctness</h3>
                    <p>We predict an interaction effect where hedged language will reduce reliance more for incorrect AI advice than for correct AI advice, improving discrimination.</p>
                    <div class="chart-container">
                        <canvas id="relianceInteractionChart"></canvas>
                    </div>
                    <p class="hypothesis-summary">H1a &amp; H1b: Hedged language reduces reliance overall, but this effect is stronger for incorrect advice, improving discrimination.</p>
                </div>
                
                <div class="prediction-chart">
                    <h3>H2: Impact of Linguistic Uncertainty on User Confidence</h3>
                    <p>We predict that hedged language will reduce participants' confidence in the AI's estimates, with a larger effect when the AI is incorrect.</p>
                    <div class="chart-container">
                        <canvas id="confidenceChart"></canvas>
                    </div>
                    <p class="hypothesis-summary">H2a: Hedged language reduces confidence in AI estimates, especially for incorrect advice.</p>
                </div>
                
                <div class="prediction-chart">
                    <h3>H3: Impact of Linguistic Uncertainty on Trust Calibration</h3>
                    <p>We predict that calibrated linguistic uncertainty will improve metacognitive calibration across user knowledge levels.</p>
                    <div class="chart-container">
                        <canvas id="calibrationErrorChart"></canvas>
                    </div>
                    <p class="hypothesis-summary">H3: Calibrated uncertainty expressions lead to better calibration (lower ECE) than consistently confident language.</p>
                </div>
                
                <div class="prediction-chart">
                    <h3>H4a: Moderation by Energy Domain Knowledge</h3>
                    <p>We predict that the benefits of calibrated uncertainty will vary depending on users' baseline energy knowledge.</p>
                    <div class="chart-container">
                        <canvas id="knowledgeModerationChart"></canvas>
                    </div>
                    <p class="hypothesis-summary">H4a: Medium-knowledge users may show the largest improvements from calibrated uncertainty cues.</p>
                </div>
                
                <div class="prediction-chart">
                    <h3>H4b: Moderation by AI Literacy</h3>
                    <p>We predict that higher AI literacy will enhance the effect of uncertainty expressions on appropriate reliance.</p>
                    <div class="chart-container">
                        <canvas id="aiLiteracyModerationChart"></canvas>
                    </div>
                    <p class="hypothesis-summary">H4b: High AI literacy users will show stronger discrimination improvements with calibrated uncertainty.</p>
                </div>
            </div>
            
            <!-- Terminology Tab (New) -->
            <div id="terminology" class="tab-pane">
                <h2>Key Terminology &amp; Concepts</h2>
                
                <p>Understanding the precise definitions of terms used in this research is essential for clarity:</p>
                
                <table class="measures-table">
                    <tbody><tr>
                        <th>Term/Concept</th>
                        <th>Definition</th>
                    </tr>
                    <tr>
                        <td><strong>Internal Confidence</strong> (AI's)</td>
                        <td>GPT-4 output layer probability of response</td>
                    </tr>
                    <tr>
                        <td><strong>Linguistic Uncertainty</strong> (AI's Expressed)</td>
                        <td>How the LLM communicates its internal uncertainty through language (e.g., confident phrasing vs. hedging terms like "might," "could be," "around")</td>
                    </tr>
                    <tr>
                        <td><strong>Confidence</strong> (User's)</td>
                        <td>Participant's subjective belief or reported probability that the AI estimate is correct</td>
                    </tr>
                    <tr>
                        <td><strong>Calibration</strong> (User's)</td>
                        <td>The alignment between a user's subjective confidence in a statement (e.g., the AI's advice) and the actual, objective accuracy of that statement</td>
                    </tr>
                    <tr>
                        <td><strong>Calibration Error</strong> (e.g., Brier Score, ECE)</td>
                        <td>DV reflecting how well users interpret the AI's reliability, rather than just their average confidence (which could be high but poorly aligned with reality) or average accuracy (which doesn't capture their metacognitive judgment)</td>
                    </tr>
                    <tr>
                        <td><strong>Calibrated Uncertainty</strong> (AI Condition)</td>
                        <td>An experimental condition where the AI's expressed linguistic uncertainty is deliberately aligned with its (simulated) internal confidence</td>
                    </tr>
                    <tr>
                        <td><strong>Reliance</strong></td>
                        <td>The extent to which a user depends on or utilizes the AI's advice. Obtained from forced-choice responses</td>
                    </tr>
                    <tr>
                        <td><strong>Trust</strong> (User's)</td>
                        <td>A broader attitude or belief in the AI's general capability, reliability</td>
                    </tr>
                </tbody></table>
                
                <div class="insight-box">
                    <p><strong>Research Note:</strong> The distinction between confidence (item-level assessment), calibration (metacognitive alignment), and trust (general attitude) is crucial for understanding the multiple dimensions of human-AI interaction in this study.</p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Dark mode detection and toggle
        const checkbox = document.getElementById('checkbox');
        const themeIcon = document.querySelector('.theme-icon');
        
        // Always start in light mode, regardless of system preference
        document.documentElement.classList.remove('dark');
        checkbox.checked = false;
        themeIcon.textContent = '☀️';
        
        // Listen for theme changes
        checkbox.addEventListener('change', function() {
            if (this.checked) {
                document.documentElement.classList.add('dark');
                themeIcon.textContent = '🌙';
            } else {
                document.documentElement.classList.remove('dark');
                themeIcon.textContent = '☀️';
            }
            
            // Redraw all charts for theme consistency
            initAllCharts();
        });
        
        // Also listen for system preference changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            document.documentElement.classList.toggle('dark', event.matches);
            checkbox.checked = event.matches;
            themeIcon.textContent = event.matches ? '🌙' : '☀️';
            
            // Redraw all charts for theme consistency
            initAllCharts();
        });
        
        // Tab functionality - simpler version to avoid white screen issues
        document.querySelectorAll('.tabs a').forEach(tab => {
            tab.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                
                // Only do work if this isn't already the active tab
                if (!this.classList.contains('active')) {
                    // Remove active class from all tabs and panes
                    document.querySelectorAll('.tabs a').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding pane
                    this.classList.add('active');
                    const targetPane = document.querySelector(targetId);
                    if (targetPane) {
                        targetPane.classList.add('active');
                    }
                    
                    // Initialize charts in the new tab if needed
                    if (['#ai-confidence', '#energy', '#individual-differences', 
                         '#predictions', '#dashboard'].includes(targetId)) {
                        // Use requestAnimationFrame for smoother transition
                        requestAnimationFrame(() => {
                            try {
                                if (targetId === '#energy') {
                                    if (typeof initEnergyPerceptionChart === 'function') {
                                        initEnergyPerceptionChart();
                                    }
                                } else if (targetId === '#ai-confidence') {
                                    if (typeof initCalibrationGapChart === 'function') {
                                        initCalibrationGapChart();
                                        createLLMInternalDiagram();
                                    }
                                } else if (targetId === '#individual-differences') {
                                    if (typeof initKnowledgeInteractionChart === 'function') {
                                        initKnowledgeInteractionChart();
                                    }
                                } else if (targetId === '#predictions') {
                                    if (typeof initRelianceInteractionChart === 'function') {
                                        initRelianceInteractionChart();
                                        initConfidenceChart();
                                        initCalibrationErrorChart();
                                        initKnowledgeModerationChart();
                                        initAILiteracyModerationChart();
                                    }
                                } else if (targetId === '#dashboard') {
                                    if (typeof initDashboardCharts === 'function') {
                                        initDashboardCharts();
                                    }
                                } else if (targetId === '#experimental-design') {
                                    if (typeof createMethodsDiagram === 'function') {
                                        createMethodsDiagram();
                                    }
                                }
                            } catch (error) {
                                console.log('Error initializing charts:', error);
                            }
                        });
                    }
                }
            });
        });
        
        // Helper for getting theme-aware colors
        function getThemeColor(colorName) {
            const isDark = document.documentElement.classList.contains('dark');
            switch(colorName) {
                case 'primary': return isDark ? '#6E6CFF' : '#5D5CDE';
                case 'secondary': return isDark ? '#3eda85' : '#2ecc71';
                case 'accent': return isDark ? '#f76354' : '#e74c3c';
                case 'text': return isDark ? '#e0e0e0' : '#2c3e50';
                case 'border': return isDark ? '#444' : '#ddd';
                case 'grid': return isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                case 'confident': return isDark ? 'rgba(255, 99, 132, 0.7)' : 'rgba(255, 99, 132, 0.7)';
                case 'hedged': return isDark ? 'rgba(54, 162, 235, 0.7)' : 'rgba(54, 162, 235, 0.7)';
                default: return '#5D5CDE';
            }
        }
        
        // Function to update chart colors based on theme
        function updateChartColors(chart) {
            if (!chart) return;
            
            // Update grid line colors
            if (chart.options.scales?.x) {
                chart.options.scales.x.grid = {
                    color: getThemeColor('grid')
                };
            }
            if (chart.options.scales?.y) {
                chart.options.scales.y.grid = {
                    color: getThemeColor('grid')
                };
            }
            
            // Update title and tick colors
            const fontColor = getThemeColor('text');
            
            if (chart.options.scales?.x) {
                chart.options.scales.x.ticks = {
                    color: fontColor
                };
                if (chart.options.scales.x.title) {
                    chart.options.scales.x.title.color = fontColor;
                }
            }
            
            if (chart.options.scales?.y) {
                chart.options.scales.y.ticks = {
                    color: fontColor
                };
                if (chart.options.scales.y.title) {
                    chart.options.scales.y.title.color = fontColor;
                }
            }
            
            // Update plugins colors
            if (chart.options.plugins?.title) {
                chart.options.plugins.title.color = fontColor;
            }
            
            if (chart.options.plugins?.legend) {
                chart.options.plugins.legend.labels = {
                    color: fontColor,
                    usePointStyle: true
                };
            }
            
            chart.update();
        }
        
        // Data for energy perception chart - expanded to match Attari et al.
        const attariDataItems = [
            { name: 'Central AC', actualEnergy: 3500, type: 'used', symbol: 'square' },
            { name: 'Electric Clothes Dryer', actualEnergy: 2500, type: 'used', symbol: 'square' },
            { name: 'Room Air Conditioner', actualEnergy: 1500, type: 'used', symbol: 'square' },
            { name: 'Dishwasher', actualEnergy: 1000, type: 'used', symbol: 'square' },
            { name: 'Space Heater', actualEnergy: 750, type: 'used', symbol: 'square' },
            { name: 'Desktop', actualEnergy: 400, type: 'used', symbol: 'square' },
            { name: 'Laptop', actualEnergy: 200, type: 'used', symbol: 'square' },
            { name: 'Stereo', actualEnergy: 100, type: 'used', symbol: 'square' },
            { name: 'Compact Fluorescent Bulb', actualEnergy: 50, type: 'used', symbol: 'square' },
            { name: 'Line-dry Clothes', actualEnergy: 1500, type: 'saved', symbol: 'circle' },
            { name: 'Washer Setting', actualEnergy: 800, type: 'saved', symbol: 'circle' },
            { name: 'Winter Thermostat', actualEnergy: 500, type: 'saved', symbol: 'circle' },
            { name: 'Summer Thermostat', actualEnergy: 300, type: 'saved', symbol: 'circle' },
            { name: 'Replace Incandescent with CFL', actualEnergy: 60, type: 'saved', symbol: 'circle' },
            { name: 'Lower Wattage Bulb', actualEnergy: 20, type: 'saved', symbol: 'circle' }
        ];
        
        // Generate data for energy perception chart
        function generateEnergyPerceptionData(underestimationFactor, overestimationFactor) {
            return attariDataItems.map(item => {
                let factor;
                if (item.actualEnergy > 1000) {
                    factor = 1 / underestimationFactor; // Underestimation for high-energy
                } else if (item.actualEnergy < 100) {
                    factor = overestimationFactor; // Overestimation for low-energy
                } else {
                    // Linear interpolation for mid-range
                    const logEnergy = Math.log10(item.actualEnergy);
                    const logLow = Math.log10(100);
                    const logHigh = Math.log10(1000);
                    const t = (logEnergy - logLow) / (logHigh - logLow);
                    factor = overestimationFactor * (1 - t) + (1 / underestimationFactor) * t;
                }
                
                // Add some noise to mimic real data variation
                const noise = 0.9 + Math.random() * 0.2; // 0.9 - 1.1
                
                return {
                    name: item.name,
                    actualEnergy: item.actualEnergy,
                    perceivedEnergy: item.actualEnergy * factor * noise,
                    type: item.type,
                    symbol: item.symbol
                };
            });
        }
        
        // Generate data for calibration gap chart
        function generateCalibrationData(gapSize, hedgingEffect) {
            const confidences = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
            
            const perfectCalibration = confidences.map(conf => ({ x: conf, y: conf }));
            
            // Human perception with default (confident) LLM explanations
            const humanPerceptionDefault = confidences.map(conf => {
                // Apply gap - higher overestimation for mid-range confidence
                const overestimation = gapSize * Math.sin((conf / 100) * Math.PI);
                return { x: conf, y: Math.min(100, conf + overestimation) };
            });
            
            // Human perception with hedged LLM explanations
            const humanPerceptionHedged = confidences.map(conf => {
                const overestimation = Math.max(0, (gapSize - hedgingEffect) * Math.sin((conf / 100) * Math.PI));
                return { x: conf, y: Math.min(100, conf + overestimation) };
            });
            
            return {
                perfectCalibration,
                humanPerceptionDefault,
                humanPerceptionHedged
            };
        }
        
        // Initialize charts
        let energyPerceptionChart, calibrationGapChart, knowledgeInteractionChart;
        let relianceInteractionChart, confidenceChart, calibrationErrorChart;
        let knowledgeModerationChart, aiLiteracyModerationChart;
        
        // Dashboard charts
        let conditionsPieChart, relianceBarChart, confidenceHistogram;
        let calibrationLineChart, knowledgeConditionChart;
        
        function initEnergyPerceptionChart() {
            const underestimationFactor = parseFloat(document.getElementById('underestimationFactor').value);
            const overestimationFactor = parseFloat(document.getElementById('overestimationFactor').value);
            
            const data = generateEnergyPerceptionData(underestimationFactor, overestimationFactor);
            
            const ctx = document.getElementById('energyPerceptionChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (energyPerceptionChart) {
                energyPerceptionChart.destroy();
            }
            
            // Separate data by type
            const energyUsedData = data.filter(item => item.type === 'used');
            const energySavedData = data.filter(item => item.type === 'saved');
            
            // Define logarithmic scale options
            const logScaleOptions = {
                type: 'logarithmic',
                min: 1,
                max: 20000,
                ticks: {
                    color: getThemeColor('text'),
                    callback: function(value) {
                        const log10 = Math.log10(value);
                        if (Math.floor(log10) === log10) {
                            return value;
                        }
                        return '';
                    }
                },
                grid: {
                    color: getThemeColor('grid')
                }
            };
            
            energyPerceptionChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Perfect Accuracy Line',
                            data: [
                                { x: 1, y: 1 },
                                { x: 20000, y: 20000 }
                            ],
                            borderColor: 'rgba(128, 128, 128, 0.5)',
                            backgroundColor: 'rgba(0, 0, 0, 0)',
                            borderDash: [5, 5],
                            borderWidth: 1,
                            pointRadius: 0,
                            showLine: true,
                            order: 1
                        },
                        {
                            label: 'Energy Used',
                            data: energyUsedData.map(item => ({
                                x: item.actualEnergy,
                                y: item.perceivedEnergy
                            })),
                            backgroundColor: getThemeColor('primary'),
                            pointStyle: 'rectRot',
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            order: 2
                        },
                        {
                            label: 'Energy Saved',
                            data: energySavedData.map(item => ({
                                x: item.actualEnergy,
                                y: item.perceivedEnergy
                            })),
                            backgroundColor: getThemeColor('secondary'),
                            pointStyle: 'circle',
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            order: 3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            ...logScaleOptions,
                            title: {
                                display: true,
                                text: 'Actual Energy Used or Saved (Wh)',
                                font: {
                                    weight: 'bold'
                                },
                                color: getThemeColor('text')
                            }
                        },
                        y: {
                            ...logScaleOptions,
                            title: {
                                display: true,
                                text: 'Perceived Energy Used or Saved (Wh)',
                                font: {
                                    weight: 'bold'
                                },
                                color: getThemeColor('text')
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Mean Perceptions of Energy Used or Saved (Attari et al. 2010)',
                            font: {
                                size: 16,
                                weight: 'bold'
                            },
                            color: getThemeColor('text')
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const datasetIndex = context.datasetIndex;
                                    const index = context.dataIndex;
                                    
                                    if (datasetIndex === 0) {
                                        return 'Perfect Accuracy Line';
                                    }
                                    
                                    let dataset = data;
                                    if (datasetIndex === 1) {
                                        dataset = energyUsedData;
                                    } else if (datasetIndex === 2) {
                                        dataset = energySavedData;
                                    }
                                    
                                    const item = dataset[index];
                                    return `${item.name}: Actual: ${item.actualEnergy}, Perceived: ${Math.round(item.perceivedEnergy)}`;
                                }
                            }
                        },
                        legend: {
                            labels: {
                                usePointStyle: true,
                                color: getThemeColor('text')
                            }
                        }
                    }
                }
            });
        }
        
        function initCalibrationGapChart() {
            const gapSize = parseInt(document.getElementById('calibrationGapSize').value);
            const hedgingEffect = parseInt(document.getElementById('hedgingEffect').value);
            
            const calibrationData = generateCalibrationData(gapSize, hedgingEffect);
            
            const ctx = document.getElementById('calibrationGapChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (calibrationGapChart) {
                calibrationGapChart.destroy();
            }
            
            calibrationGapChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Perfect Calibration',
                            data: calibrationData.perfectCalibration,
                            borderColor: getThemeColor('secondary'),
                            backgroundColor: 'rgba(46, 204, 113, 0.1)',
                            borderDash: [5, 5],
                            borderWidth: 2,
                            pointRadius: 0,
                            showLine: true,
                            fill: false
                        },
                        {
                            label: 'Human Perception (Confident Language)',
                            data: calibrationData.humanPerceptionDefault,
                            borderColor: getThemeColor('confident'),
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            borderWidth: 2,
                            pointRadius: 5,
                            showLine: true,
                            fill: false
                        },
                        {
                            label: 'Human Perception (Hedged Language)',
                            data: calibrationData.humanPerceptionHedged,
                            borderColor: getThemeColor('hedged'),
                            backgroundColor: 'rgba(54, 162, 235, 0.1)',
                            borderWidth: 2,
                            pointRadius: 5,
                            showLine: true,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Model Confidence (%)',
                                font: {
                                    weight: 'bold'
                                },
                                color: getThemeColor('text')
                            },
                            min: 0,
                            max: 100,
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Human Perception of Accuracy (%)',
                                font: {
                                    weight: 'bold'
                                },
                                color: getThemeColor('text')
                            },
                            min: 0,
                            max: 100,
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Calibration Gap: Model vs. Human Confidence (Steyvers et al. 2025)',
                            font: {
                                size: 16,
                                weight: 'bold'
                            },
                            color: getThemeColor('text')
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const conf = context.parsed.x;
                                    const perc = context.parsed.y;
                                    if (context.datasetIndex === 0) {
                                        return `Perfect Calibration: ${conf}%`;
                                    } else if (context.datasetIndex === 1) {
                                        return `Model Confidence: ${conf}%, Human Perception: ${perc.toFixed(1)}% (Confident Language)`;
                                    } else if (context.datasetIndex === 2) {
                                        return `Model Confidence: ${conf}%, Human Perception: ${perc.toFixed(1)}% (Hedged Language)`;
                                    }
                                }
                            }
                        },
                        legend: {
                            labels: {
                                usePointStyle: true,
                                color: getThemeColor('text')
                            }
                        }
                    }
                }
            });
        }
        
        function initKnowledgeInteractionChart() {
            const ctx = document.getElementById('knowledgeInteractionChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (knowledgeInteractionChart) {
                knowledgeInteractionChart.destroy();
            }
            
            knowledgeInteractionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Low Knowledge', 'Medium Knowledge', 'High Knowledge'],
                    datasets: [
                        {
                            label: 'Calibration Error (Confident Language)',
                            data: [0.35, 0.28, 0.15],
                            backgroundColor: getThemeColor('confident'),
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Calibration Error (Hedged Language)',
                            data: [0.25, 0.15, 0.10],
                            backgroundColor: getThemeColor('hedged'),
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Calibration Error (lower is better)',
                                font: {
                                    weight: 'bold'
                                },
                                color: getThemeColor('text')
                            },
                            min: 0,
                            max: 0.4,
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'User Energy Knowledge Level',
                                font: {
                                    weight: 'bold'
                                },
                                color: getThemeColor('text')
                            },
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Impact of Linguistic Uncertainty on Trust Calibration by User Knowledge Level',
                            font: {
                                size: 16,
                                weight: 'bold'
                            },
                            color: getThemeColor('text')
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(2)}`;
                                }
                            }
                        },
                        legend: {
                            labels: {
                                color: getThemeColor('text')
                            }
                        }
                    }
                }
            });
        }
        
        // Initialize the prediction charts
        function initRelianceInteractionChart() {
            const ctx = document.getElementById('relianceInteractionChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (relianceInteractionChart) {
                relianceInteractionChart.destroy();
            }
            
            relianceInteractionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Correct AI Advice', 'Incorrect AI Advice'],
                    datasets: [
                        {
                            label: 'Reliance Rate (Confident Language)',
                            data: [0.82, 0.68],
                            backgroundColor: getThemeColor('confident'),
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Reliance Rate (Hedged Language)',
                            data: [0.75, 0.40],
                            backgroundColor: getThemeColor('hedged'),
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Proportion of Trials Relying on AI Advice',
                                font: {
                                    weight: 'bold'
                                },
                                color: getThemeColor('text')
                            },
                            min: 0,
                            max: 1.0,
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'AI Advice Correctness',
                                font: {
                                    weight: 'bold'
                                },
                                color: getThemeColor('text')
                            },
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Predicted Reliance Rate by Linguistic Style and AI Advice Correctness',
                            font: {
                                size: 16,
                                weight: 'bold'
                            },
                            color: getThemeColor('text')
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${(context.parsed.y * 100).toFixed(1)}%`;
                                }
                            }
                        },
                        legend: {
                            labels: {
                                color: getThemeColor('text')
                            }
                        }
                    }
                }
            });
        }
        
        function initConfidenceChart() {
            const ctx = document.getElementById('confidenceChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (confidenceChart) {
                confidenceChart.destroy();
            }
            
            confidenceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Correct AI Advice', 'Incorrect AI Advice'],
                    datasets: [
                        {
                            label: 'User Confidence (Confident Language)',
                            data: [78, 72],
                            backgroundColor: getThemeColor('confident'),
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'User Confidence (Hedged Language)',
                            data: [65, 45],
                            backgroundColor: getThemeColor('hedged'),
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'User Confidence in AI Advice (%)',
                                font: {
                                    weight: 'bold'
                                },
                                color: getThemeColor('text')
                            },
                            min: 0,
                            max: 100,
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'AI Advice Correctness',
                                font: {
                                    weight: 'bold'
                                },
                                color: getThemeColor('text')
                            },
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Predicted User Confidence by Linguistic Style and AI Advice Correctness',
                            font: {
                                size: 16,
                                weight: 'bold'
                            },
                            color: getThemeColor('text')
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y}%`;
                                }
                            }
                        },
                        legend: {
                            labels: {
                                color: getThemeColor('text')
                            }
                        }
                    }
                }
            });
        }
        
        function initCalibrationErrorChart() {
            const ctx = document.getElementById('calibrationErrorChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (calibrationErrorChart) {
                calibrationErrorChart.destroy();
            }
            
            calibrationErrorChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Low Knowledge', 'Medium Knowledge', 'High Knowledge'],
                    datasets: [
                        {
                            label: 'Calibration Error (Confident Language)',
                            data: [0.35, 0.28, 0.15],
                            backgroundColor: getThemeColor('confident'),
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Calibration Error (Hedged Language)',
                            data: [0.25, 0.15, 0.10],
                            backgroundColor: getThemeColor('hedged'),
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Calibration Error (lower is better)',
                                font: {
                                    weight: 'bold'
                                },
                                color: getThemeColor('text')
                            },
                            min: 0,
                            max: 0.4,
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'User Energy Knowledge Level',
                                font: {
                                    weight: 'bold'
                                },
                                color: getThemeColor('text')
                            },
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Impact of Linguistic Uncertainty on Trust Calibration by User Knowledge Level',
                            font: {
                                size: 16,
                                weight: 'bold'
                            },
                            color: getThemeColor('text')
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(2)}`;
                                }
                            }
                        },
                        legend: {
                            labels: {
                                color: getThemeColor('text')
                            }
                        }
                    }
                }
            });
        }
        
        function initKnowledgeModerationChart() {
            const ctx = document.getElementById('knowledgeModerationChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (knowledgeModerationChart) {
                knowledgeModerationChart.destroy();
            }
            
            knowledgeModerationChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['Low Knowledge', 'Medium Knowledge', 'High Knowledge'],
                    datasets: [
                        {
                            label: 'Discrimination (AUC) - Confident Language',
                            data: [0.55, 0.62, 0.75],
                            backgroundColor: getThemeColor('confident'),
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 2,
                            tension: 0.1
                        },
                        {
                            label: 'Discrimination (AUC) - Hedged Language',
                            data: [0.58, 0.72, 0.82],
                            backgroundColor: getThemeColor('hedged'),
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 2,
                            tension: 0.1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Discrimination (AUC, higher is better)',
                                font: {
                                    weight: 'bold'
                                },
                                color: getThemeColor('text')
                            },
                            min: 0.5,
                            max: 0.9,
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'User Energy Knowledge Level',
                                font: {
                                    weight: 'bold'
                                },
                                color: getThemeColor('text')
                            },
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Predicted User Discrimination by Knowledge Level and Linguistic Style',
                            font: {
                                size: 16,
                                weight: 'bold'
                            },
                            color: getThemeColor('text')
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(2)}`;
                                }
                            }
                        },
                        legend: {
                            labels: {
                                color: getThemeColor('text')
                            }
                        }
                    }
                }
            });
        }
        
        function initAILiteracyModerationChart() {
            const ctx = document.getElementById('aiLiteracyModerationChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (aiLiteracyModerationChart) {
                aiLiteracyModerationChart.destroy();
            }
            
            aiLiteracyModerationChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['Low AI Literacy', 'Medium AI Literacy', 'High AI Literacy'],
                    datasets: [
                        {
                            label: 'Reliance Discrimination Index - Confident Language',
                            data: [0.08, 0.14, 0.18],
                            backgroundColor: getThemeColor('confident'),
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 2,
                            tension: 0.1
                        },
                        {
                            label: 'Reliance Discrimination Index - Hedged Language',
                            data: [0.12, 0.25, 0.42],
                            backgroundColor: getThemeColor('hedged'),
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 2,
                            tension: 0.1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Reliance Discrimination Index (higher is better)',
                                font: {
                                    weight: 'bold'
                                },
                                color: getThemeColor('text')
                            },
                            min: 0,
                            max: 0.5,
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'AI Literacy Level',
                                font: {
                                    weight: 'bold'
                                },
                                color: getThemeColor('text')
                            },
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Predicted Effect of AI Literacy on Reliance Discrimination',
                            font: {
                                size: 16,
                                weight: 'bold'
                            },
                            color: getThemeColor('text')
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(2)}`;
                                }
                            }
                        },
                        legend: {
                            labels: {
                                color: getThemeColor('text')
                            }
                        }
                    }
                }
            });
        }
        
        // Create the LLM internal state diagram with improved spacing and sizing to prevent text overflow
        function createLLMInternalDiagram() {
            const diagramContainer = document.getElementById('llmInternalDiagram');
            
            const textColor = getThemeColor('text');
            
            // SVG diagram for the LLM internal state - improved design with better spacing
            const svgContent = `
            <svg width="800" height="1000" viewBox="0 0 800 1000" xmlns="http://www.w3.org/2000/svg">
                <!-- LLM INTERNAL STATE -->
                <rect x="200" y="10" width="400" height="120" rx="10" ry="10" stroke="${textColor}" stroke-width="2" fill="none"/>
                <text x="400" y="45" text-anchor="middle" font-weight="bold" font-size="18" fill="${textColor}">LLM INTERNAL STATE</text>
                <text x="400" y="75" text-anchor="middle" font-size="16" fill="${textColor}">• Represented knowledge</text>
                <text x="400" y="105" text-anchor="middle" font-size="16" fill="${textColor}">• «Internal» confidence</text>
                
                <!-- Arrow down with label -->
                <line x1="400" y1="130" x2="400" y2="160" stroke="${textColor}" stroke-width="2" marker-end="url(#arrowhead)"/>
                <text x="520" y="150" text-anchor="middle" font-size="14" fill="${textColor}">read-out of token likelihoods</text>
                
                <!-- MODEL CONFIDENCE BOX -->
                <rect x="50" y="160" width="300" height="130" rx="10" ry="10" stroke="${textColor}" stroke-width="2" fill="none"/>
                <text x="200" y="195" text-anchor="middle" font-weight="bold" font-size="18" fill="${textColor}">MODEL CONFIDENCE</text>
                <text x="200" y="225" text-anchor="middle" font-size="16" fill="${textColor}">(numeric probability)</text>
                <text x="200" y="255" text-anchor="middle" font-size="16" fill="${textColor}">researcher extracts</text>
                
                <!-- LLM OUTPUT BOX -->
                <rect x="450" y="160" width="300" height="130" rx="10" ry="10" stroke="${textColor}" stroke-width="2" fill="none"/>
                <text x="600" y="195" text-anchor="middle" font-weight="bold" font-size="18" fill="${textColor}">LLM OUTPUT</text>
                <text x="600" y="225" text-anchor="middle" font-size="16" fill="${textColor}">• Numeric estimate</text>
                <text x="600" y="250" text-anchor="middle" font-size="16" fill="${textColor}">• Explanation text</text>
                <text x="600" y="275" text-anchor="middle" font-size="16" fill="${textColor}">• Linguistic hedging</text>
                
                <!-- Controls arrow -->
                <line x1="350" y1="215" x2="450" y2="215" stroke="${textColor}" stroke-width="2" marker-end="url(#arrowhead)"/>
                <text x="400" y="200" text-anchor="middle" font-size="14" fill="${textColor}">controls</text>
                
                <!-- Arrow to HUMAN COGNITION -->
                <line x1="600" y1="290" x2="600" y2="330" stroke="${textColor}" stroke-width="2" marker-end="url(#arrowhead)"/>
                <text x="650" y="315" text-anchor="middle" font-size="14" fill="${textColor}">presented</text>
                
                <!-- HUMAN COGNITION BOX -->
                <rect x="450" y="330" width="300" height="160" rx="10" ry="10" stroke="${textColor}" stroke-width="2" fill="none"/>
                <text x="600" y="360" text-anchor="middle" font-weight="bold" font-size="18" fill="${textColor}">HUMAN COGNITION</text>
                <text x="600" y="390" text-anchor="middle" font-size="16" fill="${textColor}">• Interpret answer</text>
                <text x="600" y="415" text-anchor="middle" font-size="16" fill="${textColor}">• Form perceived accuracy</text>
                <text x="600" y="440" text-anchor="middle" font-size="16" fill="${textColor}">• Generate confidence</text>
                <text x="600" y="465" text-anchor="middle" font-size="16" fill="${textColor}">• Make reliance choice</text>
                
                <!-- Arrow from MODEL CONFIDENCE to RESEARCH METRICS -->
                <line x1="200" y1="290" x2="200" y2="540" stroke="${textColor}" stroke-width="2" marker-end="url(#arrowhead)"/>
                
                <!-- Arrow from HUMAN COGNITION to RESEARCH METRICS (rating & choice recorded) -->
                <line x1="600" y1="490" x2="600" y2="530" stroke="${textColor}" stroke-width="2" marker-end="url(#arrowhead)"/>
                <text x="700" y="510" text-anchor="middle" font-size="14" fill="${textColor}">confidence rating &</text>
                <text x="700" y="530" text-anchor="middle" font-size="14" fill="${textColor}">choice recorded</text>
                
                <!-- RESEARCH METRICS BOX -->
                <rect x="100" y="540" width="600" height="200" rx="10" ry="10" stroke="${textColor}" stroke-width="2" fill="none"/>
                <text x="400" y="580" text-anchor="middle" font-weight="bold" font-size="18" fill="${textColor}">RESEARCH METRICS</text>
                <text x="400" y="610" text-anchor="middle" font-size="16" fill="${textColor}">• Calibration Gap = |HumanConf - ModelConf|</text>
                <text x="400" y="635" text-anchor="middle" font-size="16" fill="${textColor}">• Expected Calibration Error (ECE)</text>
                <text x="400" y="660" text-anchor="middle" font-size="16" fill="${textColor}">• Brier score (accuracy-weighted error)</text>
                <text x="400" y="685" text-anchor="middle" font-size="16" fill="${textColor}">• AUC (discrimination)</text>
                <text x="400" y="710" text-anchor="middle" font-size="16" fill="${textColor}">• Appropriate-reliance index</text>
                
                <!-- Arrow to DECISION QUALITY -->
                <line x1="400" y1="740" x2="400" y2="780" stroke="${textColor}" stroke-width="2" marker-end="url(#arrowhead)"/>
                <text x="450" y="760" text-anchor="middle" font-size="14" fill="${textColor}">informs</text>
                
                <!-- DECISION QUALITY BOX -->
                <rect x="100" y="780" width="600" height="160" rx="10" ry="10" stroke="${textColor}" stroke-width="2" fill="none"/>
                <text x="400" y="820" text-anchor="middle" font-weight="bold" font-size="18" fill="${textColor}">DECISION QUALITY & OUTCOMES</text>
                <text x="400" y="850" text-anchor="middle" font-size="16" fill="${textColor}">• Advice adoption / rejection rates</text>
                <text x="400" y="875" text-anchor="middle" font-size="16" fill="${textColor}">• Task performance (energy judgments, etc.)</text>
                <text x="400" y="900" text-anchor="middle" font-size="16" fill="${textColor}">• Design guidelines for AI advisors</text>
                
                <!-- Final arrow -->
                <line x1="400" y1="940" x2="400" y2="960" stroke="${textColor}" stroke-width="2" marker-end="url(#arrowhead)"/>
                
                <!-- Arrowhead marker -->
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="${textColor}"/>
                    </marker>
                </defs>
            </svg>
            `;
            
            diagramContainer.innerHTML = svgContent;
        }
        
        // Create the methods diagram with improved spacing to prevent text overlap
        function createMethodsDiagram() {
            const diagramContainer = document.getElementById('methodsDiagram');
            
            const textColor = getThemeColor('text');
            
            // SVG diagram for the experimental methods - improved with better spacing
            const svgContent = `
            <svg width="800" height="650" viewBox="0 0 800 650" xmlns="http://www.w3.org/2000/svg">
                <!-- Title -->
                <text x="400" y="30" text-anchor="middle" font-weight="bold" font-size="20" fill="${textColor}">Experimental Design: 2×2 Mixed Factorial</text>
                
                <!-- Phase 1 -->
                <rect x="100" y="70" width="600" height="120" rx="10" ry="10" stroke="${textColor}" stroke-width="2" fill="none"/>
                <text x="400" y="100" text-anchor="middle" font-weight="bold" font-size="18" fill="${textColor}">PHASE 1: BASELINE ENERGY KNOWLEDGE</text>
                <text x="400" y="130" text-anchor="middle" font-size="16" fill="${textColor}">Participants estimate energy consumption of various appliances</text>
                <text x="400" y="160" text-anchor="middle" font-size="16" fill="${textColor}">Establishes baseline knowledge and estimation biases</text>
                
                <!-- Arrow down -->
                <line x1="400" y1="190" x2="400" y2="220" stroke="${textColor}" stroke-width="2" marker-end="url(#arrowhead-methods)"/>
                
                <!-- Phase 2 -->
                <rect x="100" y="220" width="600" height="330" rx="10" ry="10" stroke="${textColor}" stroke-width="2" fill="none"/>
                <text x="400" y="250" text-anchor="middle" font-weight="bold" font-size="18" fill="${textColor}">PHASE 2: AI ENERGY ADVISOR INTERACTION</text>
                
                <!-- Between-subjects factor -->
                <rect x="150" y="280" width="220" height="230" rx="10" ry="10" stroke="${textColor}" stroke-width="2" fill="none"/>
                <text x="260" y="305" text-anchor="middle" font-weight="bold" font-size="16" fill="${textColor}">Condition A</text>
                <text x="260" y="335" text-anchor="middle" font-size="14" fill="${textColor}">Always Confident Language</text>
                <text x="260" y="365" text-anchor="middle" font-size="13" fill="${textColor}">"A central AC unit uses 3500</text>
                <text x="260" y="390" text-anchor="middle" font-size="13" fill="${textColor}">units of energy per hour."</text>
                <text x="260" y="415" text-anchor="middle" font-size="13" fill="${textColor}">(Consistent confidence level</text>
                <text x="260" y="440" text-anchor="middle" font-size="13" fill="${textColor}">regardless of actual accuracy)</text>
                
                <!-- VS text -->
                <text x="400" y="390" text-anchor="middle" font-weight="bold" font-size="16" fill="${textColor}">VS</text>
                
                <rect x="430" y="280" width="220" height="230" rx="10" ry="10" stroke="${textColor}" stroke-width="2" fill="none"/>
                <text x="540" y="305" text-anchor="middle" font-weight="bold" font-size="16" fill="${textColor}">Condition B</text>
                <text x="540" y="335" text-anchor="middle" font-size="14" fill="${textColor}">Calibrated Uncertainty</text>
                <text x="540" y="365" text-anchor="middle" font-size="13" fill="${textColor}">When correct: Confident language</text>
                <text x="540" y="390" text-anchor="middle" font-size="13" fill="${textColor}">When incorrect: "A central AC</text>
                <text x="540" y="415" text-anchor="middle" font-size="13" fill="${textColor}">might use approximately 3500</text>
                <text x="540" y="440" text-anchor="middle" font-size="13" fill="${textColor}">units, but I'm not entirely certain."</text>
                
                <!-- Within-subjects factors -->
                <text x="400" y="470" text-anchor="middle" font-weight="bold" font-size="16" fill="${textColor}">Within-Subjects Factors</text>
                <text x="400" y="500" text-anchor="middle" font-size="14" fill="${textColor}">• Item (10-12 energy scenarios, counterbalanced)</text>
                <text x="400" y="525" text-anchor="middle" font-size="14" fill="${textColor}">• AI Advice Correctness (correct vs. incorrect advice)</text>
                
                <!-- Arrow down -->
                <line x1="400" y1="570" x2="400" y2="600" stroke="${textColor}" stroke-width="2" marker-end="url(#arrowhead-methods)"/>
                
                <!-- Measures -->
                <text x="250" y="625" text-anchor="middle" font-weight="bold" font-size="16" fill="${textColor}">DV1: Reliance</text>
                <text x="400" y="625" text-anchor="middle" font-weight="bold" font-size="16" fill="${textColor}">DV2: Confidence</text>
                <text x="550" y="625" text-anchor="middle" font-weight="bold" font-size="16" fill="${textColor}">DV3: Calibration</text>
                
                <!-- Arrowhead marker -->
                <defs>
                    <marker id="arrowhead-methods" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="${textColor}"/>
                    </marker>
                </defs>
            </svg>
            `;
            
            diagramContainer.innerHTML = svgContent;
        }
        
        // The appliance data for simulation
        const simulationAppliances = [
            { name: 'Central Air Conditioner', actualEnergy: 3500, icon: '❄️' },
            { name: 'Water Heater', actualEnergy: 2500, icon: '🔥' },
            { name: 'Refrigerator', actualEnergy: 1800, icon: '🧊' },
            { name: 'Clothes Dryer', actualEnergy: 1500, icon: '👕' },
            { name: 'Television', actualEnergy: 500, icon: '📺' },
            { name: 'Computer', actualEnergy: 300, icon: '💻' },
            { name: 'Stereo System', actualEnergy: 100, icon: '🔊' },
            { name: 'LED Light Bulb', actualEnergy: 60, icon: '💡' }
        ];
        
        // Advice confidence levels and corresponding language templates
        const confidenceLanguage = {
            high: {
                prefix: "Based on typical usage patterns, a {appliance} definitely uses about",
                suffix: "units of energy per hour. This is because {appliance}s typically operate at {power} watts, which converts directly to this energy consumption rate."
            },
            medium: {
                prefix: "I estimate that a {appliance} probably uses approximately",
                suffix: "units of energy per hour. This is based on typical {appliance}s that tend to operate around {power} watts, though there can be some variation depending on the model and usage patterns."
            },
            low: {
                prefix: "My best guess is that a {appliance} might use roughly",
                suffix: "units of energy per hour, but I'm not entirely certain. Different models of {appliance}s can vary quite a bit, possibly ranging from {powerLow} to {powerHigh} watts depending on efficiency and features. You might want to check the specific model information."
            }
        };
        
        // Variable to keep track of simulation state
        let simulationState = {
            currentStep: 0,
            maxSteps: 5,
            appliances: [],
            userEstimates: {},
            aiEstimates: {},
            userChoices: [],
            userConfidence: [],
            correctChoices: 0,
            results: {
                calibrationError: 0,
                appropriateReliance: 0
            }
        };
        
        // Dashboard data and state
        let dashboardState = {
            isRunning: false,
            updateInterval: 5000,
            timer: null,
            participantCount: 0,
            participantTarget: 120,
            conditionAssignment: {
                confident: 0,
                calibrated: 0
            },
            relianceData: {
                confident: {
                    correct: [],
                    incorrect: []
                },
                calibrated: {
                    correct: [],
                    incorrect: []
                }
            },
            confidenceData: {
                confident: [],
                calibrated: []
            },
            calibrationErrorData: {
                confident: [],
                calibrated: []
            },
            timePoints: [],
            knowledgeLevels: {
                confident: {
                    low: { reliance: [], calibration: [] },
                    medium: { reliance: [], calibration: [] },
                    high: { reliance: [], calibration: [] }
                },
                calibrated: {
                    low: { reliance: [], calibration: [] },
                    medium: { reliance: [], calibration: [] },
                    high: { reliance: [], calibration: [] }
                }
            },
            insights: [
                "Experiment dashboard initializing...",
                "Ready to collect or simulate data.",
                "Configure settings and click 'Start Dashboard' to begin."
            ]
        };
        
        // Function to initialize dashboard charts
        function initDashboardCharts() {
            initConditionsPieChart();
            initRelianceBarChart();
            initConfidenceHistogram();
            initCalibrationLineChart();
            initKnowledgeConditionChart();
        }
        
        function initConditionsPieChart() {
            const ctx = document.getElementById('conditionsPieChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (conditionsPieChart) {
                conditionsPieChart.destroy();
            }
            
            conditionsPieChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: ['Always Confident', 'Calibrated Uncertainty'],
                    datasets: [{
                        data: [
                            dashboardState.conditionAssignment.confident,
                            dashboardState.conditionAssignment.calibrated
                        ],
                        backgroundColor: [
                            getThemeColor('confident'),
                            getThemeColor('hedged')
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: getThemeColor('text')
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.raw || 0;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = total > 0 ? Math.round((value / total) * 100) : 0;
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function initRelianceBarChart() {
            const ctx = document.getElementById('relianceBarChart').getContext('2d');
            
            // Calculate average reliance
            const confCorrect = dashboardState.relianceData.confident.correct.length > 0 
                ? dashboardState.relianceData.confident.correct.reduce((a, b) => a + b, 0) / dashboardState.relianceData.confident.correct.length 
                : 0;
                
            const confIncorrect = dashboardState.relianceData.confident.incorrect.length > 0 
                ? dashboardState.relianceData.confident.incorrect.reduce((a, b) => a + b, 0) / dashboardState.relianceData.confident.incorrect.length 
                : 0;
                
            const calCorrect = dashboardState.relianceData.calibrated.correct.length > 0 
                ? dashboardState.relianceData.calibrated.correct.reduce((a, b) => a + b, 0) / dashboardState.relianceData.calibrated.correct.length 
                : 0;
                
            const calIncorrect = dashboardState.relianceData.calibrated.incorrect.length > 0 
                ? dashboardState.relianceData.calibrated.incorrect.reduce((a, b) => a + b, 0) / dashboardState.relianceData.calibrated.incorrect.length 
                : 0;
            
            // Destroy existing chart if it exists
            if (relianceBarChart) {
                relianceBarChart.destroy();
            }
            
            relianceBarChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['When AI Correct', 'When AI Incorrect'],
                    datasets: [
                        {
                            label: 'Confident Language',
                            data: [confCorrect, confIncorrect],
                            backgroundColor: getThemeColor('confident'),
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Calibrated Uncertainty',
                            data: [calCorrect, calIncorrect],
                            backgroundColor: getThemeColor('hedged'),
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 1,
                            title: {
                                display: true,
                                text: 'Reliance Rate',
                                color: getThemeColor('text')
                            },
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        },
                        x: {
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: getThemeColor('text')
                            }
                        }
                    }
                }
            });
        }
        
        function initConfidenceHistogram() {
            const ctx = document.getElementById('confidenceHistogram').getContext('2d');
            
            // Destroy existing chart if it exists
            if (confidenceHistogram) {
                confidenceHistogram.destroy();
            }
            
            // Prepare histogram data
            const confData = dashboardState.confidenceData.confident;
            const calData = dashboardState.confidenceData.calibrated;
            
            // Bin confidence values
            const bins = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
            const confCounts = Array(10).fill(0);
            const calCounts = Array(10).fill(0);
            
            confData.forEach(val => {
                const binIndex = Math.min(Math.floor(val / 10), 9);
                confCounts[binIndex]++;
            });
            
            calData.forEach(val => {
                const binIndex = Math.min(Math.floor(val / 10), 9);
                calCounts[binIndex]++;
            });
            
            confidenceHistogram = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['0-10', '11-20', '21-30', '31-40', '41-50', '51-60', '61-70', '71-80', '81-90', '91-100'],
                    datasets: [
                        {
                            label: 'Confident Language',
                            data: confCounts,
                            backgroundColor: getThemeColor('confident'),
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Calibrated Uncertainty',
                            data: calCounts,
                            backgroundColor: getThemeColor('hedged'),
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency',
                                color: getThemeColor('text')
                            },
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Confidence Rating (%)',
                                color: getThemeColor('text')
                            },
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: getThemeColor('text')
                            }
                        }
                    }
                }
            });
        }
        
        function initCalibrationLineChart() {
            const ctx = document.getElementById('calibrationLineChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (calibrationLineChart) {
                calibrationLineChart.destroy();
            }
            
            // Prepare data for the line chart
            const confData = dashboardState.calibrationErrorData.confident;
            const calData = dashboardState.calibrationErrorData.calibrated;
            const timePoints = dashboardState.timePoints;
            
            // Format labels as timestamps
            const formattedLabels = timePoints.map(time => {
                const date = new Date(time);
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            });
            
            calibrationLineChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: formattedLabels.length > 0 ? formattedLabels : ['Start'],
                    datasets: [
                        {
                            label: 'Confident Language',
                            data: confData.length > 0 ? confData : [0],
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            tension: 0.4,
                            fill: true
                        },
                        {
                            label: 'Calibrated Uncertainty',
                            data: calData.length > 0 ? calData : [0],
                            borderColor: 'rgba(54, 162, 235, 1)',
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            tension: 0.4,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 0.5,
                            title: {
                                display: true,
                                text: 'Calibration Error (lower is better)',
                                color: getThemeColor('text')
                            },
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Time',
                                color: getThemeColor('text')
                            },
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: getThemeColor('text')
                            }
                        }
                    }
                }
            });
        }
        
        function initKnowledgeConditionChart() {
            const ctx = document.getElementById('knowledgeConditionChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (knowledgeConditionChart) {
                knowledgeConditionChart.destroy();
            }
            
            // Calculate average calibration error for each knowledge level and condition
            function calculateAverage(array) {
                return array.length > 0 ? array.reduce((a, b) => a + b, 0) / array.length : 0;
            }
            
            const confLow = calculateAverage(dashboardState.knowledgeLevels.confident.low.calibration);
            const confMed = calculateAverage(dashboardState.knowledgeLevels.confident.medium.calibration);
            const confHigh = calculateAverage(dashboardState.knowledgeLevels.confident.high.calibration);
            
            const calLow = calculateAverage(dashboardState.knowledgeLevels.calibrated.low.calibration);
            const calMed = calculateAverage(dashboardState.knowledgeLevels.calibrated.medium.calibration);
            const calHigh = calculateAverage(dashboardState.knowledgeLevels.calibrated.high.calibration);
            
            knowledgeConditionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Low Knowledge', 'Medium Knowledge', 'High Knowledge'],
                    datasets: [
                        {
                            label: 'Confident Language',
                            data: [confLow || 0.35, confMed || 0.28, confHigh || 0.15],
                            backgroundColor: getThemeColor('confident'),
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Calibrated Uncertainty',
                            data: [calLow || 0.25, calMed || 0.15, calHigh || 0.10],
                            backgroundColor: getThemeColor('hedged'),
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 0.5,
                            title: {
                                display: true,
                                text: 'Calibration Error',
                                color: getThemeColor('text')
                            },
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        },
                        x: {
                            ticks: {
                                color: getThemeColor('text')
                            },
                            grid: {
                                color: getThemeColor('grid')
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: getThemeColor('text')
                            }
                        }
                    }
                }
            });
        }
        
        // Function to refresh all dashboard charts
        function refreshDashboardCharts() {
            initConditionsPieChart();
            initRelianceBarChart();
            initConfidenceHistogram();
            initCalibrationLineChart();
            initKnowledgeConditionChart();
            
            // Update participant statistics
            document.getElementById('participantCount').textContent = dashboardState.participantCount;
            document.getElementById('participantTarget').textContent = dashboardState.participantTarget;
            document.getElementById('participantProgress').style.width = 
                Math.min(100, (dashboardState.participantCount / dashboardState.participantTarget) * 100) + '%';
        }
        
        // Function to simulate a new participant's data
        function simulateNewParticipant() {
            // Simulate condition assignment
            const condition = Math.random() > 0.5 ? 'confident' : 'calibrated';
            dashboardState.conditionAssignment[condition]++;
            
            // Simulate knowledge level
            const knowledgeLevelRand = Math.random();
            const knowledgeLevel = knowledgeLevelRand < 0.33 ? 'low' : (knowledgeLevelRand < 0.66 ? 'medium' : 'high');
            
            // Base accuracy (proportion of correct trials)
            const baseAccuracy = {
                confident: condition === 'confident' ? 0.7 : 0,
                calibrated: condition === 'calibrated' ? 0.7 : 0
            };
            
            // Knowledge level affects baseline estimation accuracy
            const knowledgeBonus = {
                low: -0.1,
                medium: 0,
                high: 0.1
            };
            
            // Confidence base levels
            const baseConfidence = {
                confident: {
                    correct: 0.75,
                    incorrect: 0.65
                },
                calibrated: {
                    correct: 0.70,
                    incorrect: 0.45
                }
            };
            
            // Simulate 10 trials for this participant
            let correctChoices = 0;
            let relianceOnCorrect = 0;
            let relianceOnIncorrect = 0;
            let correctTrials = 0;
            let incorrectTrials = 0;
            
            for (let i = 0; i < 10; i++) {
                // Is the AI correct in this trial?
                const aiCorrect = Math.random() < (baseAccuracy[condition] + knowledgeBonus[knowledgeLevel]);
                
                // User's confidence in the AI's estimate
                let confidence;
                if (aiCorrect) {
                    confidence = baseConfidence[condition].correct * (0.9 + 0.2 * Math.random());
                } else {
                    confidence = baseConfidence[condition].incorrect * (0.9 + 0.2 * Math.random());
                }
                confidence = Math.min(100, Math.round(confidence * 100));
                
                // Add to confidence data
                dashboardState.confidenceData[condition].push(confidence);
                
                // Does the user rely on the AI?
                const confidenceThreshold = condition === 'calibrated' ? 0.5 : 0.6;
                const reliesOnAI = Math.random() < (confidence / 100);
                
                // Record reliance based on AI correctness
                if (aiCorrect) {
                    dashboardState.relianceData[condition].correct.push(reliesOnAI ? 1 : 0);
                    relianceOnCorrect += reliesOnAI ? 1 : 0;
                    correctTrials++;
                } else {
                    dashboardState.relianceData[condition].incorrect.push(reliesOnAI ? 1 : 0);
                    relianceOnIncorrect += reliesOnAI ? 1 : 0;
                    incorrectTrials++;
                }
                
                // Track if user made correct choice
                if ((aiCorrect && reliesOnAI) || (!aiCorrect && !reliesOnAI)) {
                    correctChoices++;
                }
            }
            
            // Calculate calibration error for this participant
            const relianceRate = (relianceOnCorrect + relianceOnIncorrect) / 10;
            const correctRate = correctChoices / 10;
            const calibrationError = Math.abs(relianceRate - correctRate);
            
            // Add to calibration error data
            dashboardState.calibrationErrorData[condition].push(calibrationError);
            
            // Add to knowledge level data
            dashboardState.knowledgeLevels[condition][knowledgeLevel].calibration.push(calibrationError);
            
            if (correctTrials > 0) {
                const relianceCorrect = relianceOnCorrect / correctTrials;
                dashboardState.knowledgeLevels[condition][knowledgeLevel].reliance.push(relianceCorrect);
            }
            
            // Add timestamp
            dashboardState.timePoints.push(Date.now());
            
            // Increment participant count
            dashboardState.participantCount++;
            
            // Generate insight if needed
            if (dashboardState.participantCount % 5 === 0) {
                generateInsight();
            }
            
            // Refresh dashboard
            refreshDashboardCharts();
        }
        
        // Function to generate insights
        function generateInsight() {
            const insights = [
                `Latest participant (#${dashboardState.participantCount}) assigned to the ${dashboardState.conditionAssignment.confident > dashboardState.conditionAssignment.calibrated ? 'confident language' : 'calibrated uncertainty'} condition.`,
                `Current data shows ${getSignificantResult()}`,
                `${getConditionComparison()}`,
                `Participant pool shows a distribution of ${Math.round((dashboardState.participantCount / dashboardState.participantTarget) * 100)}% of target sample size.`,
                `${getKnowledgeInsight()}`
            ];
            
            // Add a random insight
            const newInsight = insights[Math.floor(Math.random() * insights.length)];
            dashboardState.insights.unshift(newInsight);
            
            // Keep only the 5 most recent insights
            if (dashboardState.insights.length > 5) {
                dashboardState.insights = dashboardState.insights.slice(0, 5);
            }
            
            // Update the DOM
            const insightsContainer = document.getElementById('liveInsights');
            insightsContainer.innerHTML = '';
            dashboardState.insights.forEach(insight => {
                const li = document.createElement('li');
                li.textContent = insight;
                insightsContainer.appendChild(li);
            });
        }
        
        // Helper functions for insights
        function getSignificantResult() {
            if (dashboardState.participantCount < 10) {
                return "insufficient data for statistical conclusions yet.";
            }
            
            const results = [
                "participants in the calibrated condition show better trust calibration (lower calibration error).",
                "users with higher knowledge levels rely on AI more appropriately regardless of condition.",
                "hedged language is reducing reliance on incorrect AI advice more than on correct advice.",
                "a trend toward better discrimination in the calibrated uncertainty condition.",
                "participants in both conditions overestimate AI accuracy for low-energy appliances."
            ];
            
            return results[Math.floor(Math.random() * results.length)];
        }
        
        function getConditionComparison() {
            const confRelianceCorrect = dashboardState.relianceData.confident.correct.reduce((a, b) => a + b, 0) / Math.max(1, dashboardState.relianceData.confident.correct.length);
            const confRelianceIncorrect = dashboardState.relianceData.confident.incorrect.reduce((a, b) => a + b, 0) / Math.max(1, dashboardState.relianceData.confident.incorrect.length);
            
            const calRelianceCorrect = dashboardState.relianceData.calibrated.correct.reduce((a, b) => a + b, 0) / Math.max(1, dashboardState.relianceData.calibrated.correct.length);
            const calRelianceIncorrect = dashboardState.relianceData.calibrated.incorrect.reduce((a, b) => a + b, 0) / Math.max(1, dashboardState.relianceData.calibrated.incorrect.length);
            
            const confDiscrimination = confRelianceCorrect - confRelianceIncorrect;
            const calDiscrimination = calRelianceCorrect - calRelianceIncorrect;
            
            if (Math.abs(calDiscrimination - confDiscrimination) < 0.1) {
                return "Both conditions show similar levels of discrimination between correct and incorrect advice.";
            } else if (calDiscrimination > confDiscrimination) {
                return "The calibrated uncertainty condition shows better discrimination between correct and incorrect AI advice.";
            } else {
                return "The confident language condition unexpectedly shows better discrimination than the calibrated condition.";
            }
        }
        
        function getKnowledgeInsight() {
            const insights = [
                "Medium-knowledge participants are showing the largest benefit from calibrated uncertainty cues.",
                "High-knowledge participants discriminate well between correct and incorrect advice in both conditions.",
                "Low-knowledge participants struggle to evaluate AI advice even with uncertainty cues.",
                "The knowledge × condition interaction is emerging as predicted in our hypotheses."
            ];
            
            return insights[Math.floor(Math.random() * insights.length)];
        }
        
        // Dashboard control functions
        function startDashboard() {
            const interval = parseInt(document.getElementById('dashUpdateInterval').value) * 1000;
            dashboardState.updateInterval = interval;
            dashboardState.isRunning = true;
            
            // Update UI
            document.getElementById('startDashboard').style.display = 'none';
            document.getElementById('pauseDashboard').style.display = 'block';
            document.getElementById('resetDashboard').style.display = 'block';
            document.getElementById('dashboardStatus').textContent = 'Running';
            document.getElementById('dashboardStatus').className = 'dashboard-status active';
            
            // Start the simulation
            simulateNewParticipant();
            dashboardState.timer = setInterval(simulateNewParticipant, interval);
        }
        
        function pauseDashboard() {
            dashboardState.isRunning = false;
            clearInterval(dashboardState.timer);
            
            // Update UI
            document.getElementById('startDashboard').style.display = 'block';
            document.getElementById('startDashboard').textContent = 'Resume';
            document.getElementById('pauseDashboard').style.display = 'none';
            document.getElementById('dashboardStatus').textContent = 'Paused';
            document.getElementById('dashboardStatus').className = 'dashboard-status inactive';
        }
        
        function resetDashboard() {
            // Clear the timer
            clearInterval(dashboardState.timer);
            
            // Reset the dashboard state
            dashboardState = {
                isRunning: false,
                updateInterval: parseInt(document.getElementById('dashUpdateInterval').value) * 1000,
                timer: null,
                participantCount: 0,
                participantTarget: 120,
                conditionAssignment: {
                    confident: 0,
                    calibrated: 0
                },
                relianceData: {
                    confident: {
                        correct: [],
                        incorrect: []
                    },
                    calibrated: {
                        correct: [],
                        incorrect: []
                    }
                },
                confidenceData: {
                    confident: [],
                    calibrated: []
                },
                calibrationErrorData: {
                    confident: [],
                    calibrated: []
                },
                timePoints: [],
                knowledgeLevels: {
                    confident: {
                        low: { reliance: [], calibration: [] },
                        medium: { reliance: [], calibration: [] },
                        high: { reliance: [], calibration: [] }
                    },
                    calibrated: {
                        low: { reliance: [], calibration: [] },
                        medium: { reliance: [], calibration: [] },
                        high: { reliance: [], calibration: [] }
                    }
                },
                insights: [
                    "Dashboard reset. Ready for new data collection.",
                    "Configure settings and click 'Start Dashboard' to begin."
                ]
            };
            
            // Update UI
            document.getElementById('startDashboard').style.display = 'block';
            document.getElementById('startDashboard').textContent = 'Start Dashboard';
            document.getElementById('pauseDashboard').style.display = 'none';
            document.getElementById('resetDashboard').style.display = 'none';
            document.getElementById('dashboardStatus').textContent = 'Reset';
            document.getElementById('dashboardStatus').className = 'dashboard-status';
            
            // Update insights
            const insightsContainer = document.getElementById('liveInsights');
            insightsContainer.innerHTML = '';
            dashboardState.insights.forEach(insight => {
                const li = document.createElement('li');
                li.textContent = insight;
                insightsContainer.appendChild(li);
            });
            
            // Refresh charts
            refreshDashboardCharts();
        }
        
        // Initialize dashboard update interval display
        document.getElementById('dashUpdateInterval').addEventListener('input', function() {
            document.getElementById('updateIntervalValue').textContent = this.value;
            dashboardState.updateInterval = parseInt(this.value) * 1000;
            
            // If dashboard is running, update the interval
            if (dashboardState.isRunning) {
                clearInterval(dashboardState.timer);
                dashboardState.timer = setInterval(simulateNewParticipant, dashboardState.updateInterval);
            }
        });
        
        // Dashboard control event listeners
        document.getElementById('startDashboard').addEventListener('click', startDashboard);
        document.getElementById('pauseDashboard').addEventListener('click', pauseDashboard);
        document.getElementById('resetDashboard').addEventListener('click', resetDashboard);
        
        // Function to start a new simulation
        function startNewSimulation() {
            // Reset simulation state
            simulationState = {
                currentStep: 0,
                maxSteps: 5,
                appliances: [],
                userEstimates: {},
                aiEstimates: {},
                userChoices: [],
                userConfidence: [],
                correctChoices: 0,
                results: {
                    calibrationError: 0,
                    appropriateReliance: 0
                }
            };
            
            // Get parameter values
            const uncertaintyLevel = parseInt(document.getElementById('uncertaintyLevel').value);
            const userKnowledgeLevel = parseInt(document.getElementById('userKnowledgeLevel').value);
            const aiAccuracy = parseInt(document.getElementById('aiAccuracy').value);
            
            // Select 5 random appliances for the simulation
            simulationState.appliances = [...simulationAppliances]
                .sort(() => 0.5 - Math.random())
                .slice(0, simulationState.maxSteps);
            
            // Generate user estimates based on knowledge level
            simulationState.appliances.forEach(appliance => {
                let errorFactor;
                if (appliance.actualEnergy > 1000) {
                    // For high-energy appliances
                    errorFactor = userKnowledgeLevel === 0 ? 0.3 : (userKnowledgeLevel === 1 ? 0.5 : 0.8);
                } else {
                    // For low-energy appliances
                    errorFactor = userKnowledgeLevel === 0 ? 3 : (userKnowledgeLevel === 1 ? 2 : 1.2);
                }
                
                // Add some noise to make it more realistic
                const noise = 0.9 + Math.random() * 0.2; // 0.9 - 1.1
                simulationState.userEstimates[appliance.name] = Math.round(appliance.actualEnergy * errorFactor * noise);
            });
            
            // Generate AI estimates based on accuracy
            simulationState.appliances.forEach(appliance => {
                // Determine if this estimate will be correct or not
                const isCorrect = Math.random() * 100 < aiAccuracy;
                
                if (isCorrect) {
                    simulationState.aiEstimates[appliance.name] = {
                        value: appliance.actualEnergy,
                        confidence: 'high',
                        isCorrect: true
                    };
                } else {
                    // Generate an incorrect estimate
                    let errorDirection;
                    if (appliance.actualEnergy > 1000) {
                        errorDirection = -1; // Underestimate high-energy appliances
                    } else {
                        errorDirection = 1; // Overestimate low-energy appliances
                    }
                    
                    const errorFactor = 0.5 + Math.random() * 1.5; // Error factor between 0.5x and 2x
                    const aiEstimate = Math.round(appliance.actualEnergy * (1 + errorDirection * errorFactor));
                    
                    // Assign confidence based on how wrong it is and uncertainty level setting
                    let confidence;
                    const errorPercentage = Math.abs(aiEstimate - appliance.actualEnergy) / appliance.actualEnergy;
                    
                    if (uncertaintyLevel === 0) {
                        // Always confident regardless of correctness
                        confidence = 'high';
                    } else {
                        // Calibrated uncertainty - hedging proportional to error
                        if (errorPercentage < 0.3) {
                            confidence = 'medium';
                        } else {
                            confidence = 'low';
                        }
                    }
                    
                    simulationState.aiEstimates[appliance.name] = {
                        value: aiEstimate,
                        confidence: confidence,
                        isCorrect: false
                    };
                }
            });
            
            // Hide results area until simulation is complete
            document.getElementById('simulationResults').style.display = 'none';
            
            // Start the first step
            showSimulationStep();
        }
        
        // Function to show the current simulation step
        function showSimulationStep() {
            if (simulationState.currentStep >= simulationState.maxSteps) {
                // Simulation is complete, show results
                showSimulationResults();
                return;
            }
            
            const appliance = simulationState.appliances[simulationState.currentStep];
            const userEstimate = simulationState.userEstimates[appliance.name];
            const aiEstimate = simulationState.aiEstimates[appliance.name];
            
            // Create the simulation step UI
            const simulationArea = document.getElementById('simulationArea');
            simulationArea.innerHTML = `
                <h3>Step ${simulationState.currentStep + 1} of ${simulationState.maxSteps}: Energy Estimation</h3>
                
                <div class="appliance-info">
                    <div class="appliance-icon">${appliance.icon}</div>
                    <h4>${appliance.name}</h4>
                </div>
                
                <p>In the previous phase, you estimated that a ${appliance.name} uses <strong>${userEstimate} units</strong> of energy per hour.</p>
                
                <div class="advice-box advice-${aiEstimate.confidence}">
                    <p><strong>AI Energy Advisor:</strong></p>
                    <p>
                        ${getAdviceText(appliance, aiEstimate)}
                    </p>
                </div>
                
                <div class="user-controls">
                    <p><strong>How confident are you that the AI's estimate is correct?</strong></p>
                    <div class="confidence-slider-container">
                        <input type="range" id="confidenceSlider" min="0" max="100" value="50" style="width: 100%;">
                        <div class="confidence-labels">
                            <span>Not confident at all (0%)</span>
                            <span id="confidenceValue">50%</span>
                            <span>Extremely confident (100%)</span>
                        </div>
                    </div>
                    
                    <p style="margin-top: 20px;"><strong>Whose estimate do you think is more accurate?</strong></p>
                    <div class="decision-btns">
                        <button id="chooseUser" class="btn user-btn">My Estimate (${userEstimate} units)</button>
                        <button id="chooseAI" class="btn ai-btn">AI's Estimate (${aiEstimate.value} units)</button>
                    </div>
                </div>
            `;
            
            // Add event listeners
            document.getElementById('confidenceSlider').addEventListener('input', function() {
                document.getElementById('confidenceValue').textContent = this.value + '%';
            });
            
            document.getElementById('chooseUser').addEventListener('click', function() {
                const confidenceValue = parseInt(document.getElementById('confidenceSlider').value);
                recordUserChoice('user', confidenceValue);
            });
            
            document.getElementById('chooseAI').addEventListener('click', function() {
                const confidenceValue = parseInt(document.getElementById('confidenceSlider').value);
                recordUserChoice('ai', confidenceValue);
            });
        }
        
        // Function to get AI advice text based on confidence and appliance
        function getAdviceText(appliance, aiEstimate) {
            const language = confidenceLanguage[aiEstimate.confidence];
            
            // Calculate approximate power in watts (for the explanation)
            const power = Math.round(aiEstimate.value);
            const powerLow = Math.round(power * 0.7);
            const powerHigh = Math.round(power * 1.3);
            
            let prefix = language.prefix.replace('{appliance}', appliance.name.toLowerCase());
            let suffix = language.suffix
                .replace('{appliance}', appliance.name.toLowerCase())
                .replace('{power}', power)
                .replace('{powerLow}', powerLow)
                .replace('{powerHigh}', powerHigh);
                
            return `${prefix} <strong>${aiEstimate.value}</strong> ${suffix}`;
        }
        
        // Function to record user's choice and move to next step
        function recordUserChoice(choice, confidenceValue) {
            const appliance = simulationState.appliances[simulationState.currentStep];
            const aiEstimate = simulationState.aiEstimates[appliance.name];
            const userEstimate = simulationState.userEstimates[appliance.name];
            
            // Determine if the user's choice was correct
            const aiError = Math.abs(aiEstimate.value - appliance.actualEnergy);
            const userError = Math.abs(userEstimate - appliance.actualEnergy);
            const correctChoice = aiError < userError ? 'ai' : 'user';
            
            // Record the choice and confidence
            simulationState.userChoices.push({
                step: simulationState.currentStep,
                appliance: appliance.name,
                choice: choice,
                correctChoice: correctChoice,
                userEstimate: userEstimate,
                aiEstimate: aiEstimate.value,
                aiConfidence: aiEstimate.confidence,
                actualEnergy: appliance.actualEnergy,
                isCorrectChoice: choice === correctChoice
            });
            
            simulationState.userConfidence.push(confidenceValue);
            
            if (choice === correctChoice) {
                simulationState.correctChoices++;
            }
            
            // Move to the next step
            simulationState.currentStep++;
            showSimulationStep();
        }
        
        // Function to show the simulation results
        function showSimulationResults() {
            // Calculate results metrics
            calculateSimulationResults();
            
            const resultsArea = document.getElementById('simulationResults');
            resultsArea.style.display = 'block';
            
            // Create a summary table
            let tableHTML = `
                <h3>Simulation Results</h3>
                <p>You correctly identified the more accurate estimate ${simulationState.correctChoices} out of ${simulationState.maxSteps} times (${Math.round(simulationState.correctChoices/simulationState.maxSteps*100)}% accuracy).</p>
                
                <h4>Decision Summary:</h4>
                <table>
                    <tr>
                        <th>Appliance</th>
                        <th>Your Estimate</th>
                        <th>AI Estimate</th>
                        <th>Actual Value</th>
                        <th>AI Certainty</th>
                        <th>Your Choice</th>
                        <th>Correct?</th>
                    </tr>
            `;
            
            simulationState.userChoices.forEach(choice => {
                tableHTML += `
                    <tr>
                        <td>${choice.appliance}</td>
                        <td>${choice.userEstimate}</td>
                        <td>${choice.aiEstimate}</td>
                        <td>${choice.actualEnergy}</td>
                        <td>${choice.aiConfidence.charAt(0).toUpperCase() + choice.aiConfidence.slice(1)}</td>
                        <td>${choice.choice === 'user' ? 'Your Estimate' : 'AI Estimate'}</td>
                        <td class="${choice.isCorrectChoice ? 'correct' : 'incorrect'}">${choice.isCorrectChoice ? '✓' : '✗'}</td>
                    </tr>
                `;
            });
            
            tableHTML += `</table>`;
            
            // Add calibration analysis
            tableHTML += `
                <h4>Trust Calibration Analysis:</h4>
                <p>Calibration Error: ${simulationState.results.calibrationError.toFixed(2)} (lower is better)</p>
                <p>Appropriate Reliance: ${simulationState.results.appropriateReliance.toFixed(2)} (higher is better)</p>
                
                <div class="insight-box">
                    <h4>Key Insights:</h4>
                    <ul>
                        <li>When the AI expressed ${getAIUncertaintyLevelText()}, you relied on its advice ${getRelianceRateText()}.</li>
                        <li>Your confidence in the AI's estimates was ${getConfidenceCalibrationText()}.</li>
                        <li>Your energy knowledge level (${getUserKnowledgeLevelText()}) appeared to ${getKnowledgeImpactText()}.</li>
                    </ul>
                </div>
                
                <button id="newSimulation" class="btn" style="margin-top: 15px;">Start New Simulation</button>
            `;
            
            resultsArea.innerHTML = tableHTML;
            
            // Add event listener for new simulation button
            document.getElementById('newSimulation').addEventListener('click', function() {
                startNewSimulation();
            });
        }
        
        // Helper functions for generating the results text
        function getAIUncertaintyLevelText() {
            const level = parseInt(document.getElementById('uncertaintyLevel').value);
            return level === 0 ? "high confidence" : "calibrated uncertainty";
        }
        
        function getRelianceRateText() {
            const aiChoiceCount = simulationState.userChoices.filter(c => c.choice === 'ai').length;
            const rate = aiChoiceCount / simulationState.maxSteps;
            
            if (rate > 0.8) return "very frequently";
            if (rate > 0.6) return "frequently";
            if (rate > 0.4) return "moderately";
            if (rate > 0.2) return "occasionally";
            return "rarely";
        }
        
        function getConfidenceCalibrationText() {
            if (simulationState.results.calibrationError < 0.15) return "well-calibrated";
            if (simulationState.results.calibrationError < 0.25) return "moderately calibrated";
            return "poorly calibrated";
        }
        
        function getUserKnowledgeLevelText() {
            const level = parseInt(document.getElementById('userKnowledgeLevel').value);
            return level === 0 ? "low" : (level === 1 ? "medium" : "high");
        }
        
        function getKnowledgeImpactText() {
            const correctRate = simulationState.correctChoices / simulationState.maxSteps;
            if (correctRate > 0.8) return "significantly improve your decision-making";
            if (correctRate > 0.6) return "help you make better decisions";
            if (correctRate > 0.4) return "somewhat influence your decisions";
            return "not strongly impact your decision quality";
        }
        
        // Calculate result metrics for the simulation
        function calculateSimulationResults() {
            // Calculate calibration error (simplified Brier score)
            let squaredErrorSum = 0;
            
            simulationState.userChoices.forEach((choice, index) => {
                const confidence = simulationState.userConfidence[index] / 100;
                const outcome = choice.isCorrectChoice ? 1 : 0;
                squaredErrorSum += (confidence - outcome) ** 2;
            });
            
            simulationState.results.calibrationError = squaredErrorSum / simulationState.maxSteps;
            
            // Calculate appropriate reliance (discrimination index)
            const aiCorrectChoices = simulationState.userChoices.filter(c => {
                const aiIsCorrect = Math.abs(c.aiEstimate - c.actualEnergy) < Math.abs(c.userEstimate - c.actualEnergy);
                return (aiIsCorrect && c.choice === 'ai') || (!aiIsCorrect && c.choice === 'user');
            });
            
            simulationState.results.appropriateReliance = aiCorrectChoices.length / simulationState.maxSteps;
        }
        
        // Event listeners for the sliders
        document.getElementById('underestimationFactor').addEventListener('input', function() {
            document.getElementById('underestimationValue').textContent = this.value;
        });
        
        document.getElementById('overestimationFactor').addEventListener('input', function() {
            document.getElementById('overestimationValue').textContent = this.value;
        });
        
        document.getElementById('calibrationGapSize').addEventListener('input', function() {
            document.getElementById('calibrationGapValue').textContent = this.value;
        });
        
        document.getElementById('hedgingEffect').addEventListener('input', function() {
            document.getElementById('hedgingEffectValue').textContent = this.value;
        });
        
        document.getElementById('userKnowledgeLevel').addEventListener('input', function() {
            const value = parseInt(this.value);
            const levelText = value === 0 ? 'Low' : (value === 1 ? 'Medium' : 'High');
            document.getElementById('userKnowledgeValue').textContent = levelText;
        });
        
        document.getElementById('aiAccuracy').addEventListener('input', function() {
            document.getElementById('aiAccuracyValue').textContent = this.value;
        });
        
        // Event listeners for the button actions
        document.getElementById('updateEnergyChart').addEventListener('click', function() {
            initEnergyPerceptionChart();
        });
        
        document.getElementById('updateCalibrationChart').addEventListener('click', function() {
            initCalibrationGapChart();
        });
        
        document.getElementById('startSimulation').addEventListener('click', function() {
            startNewSimulation();
        });
        
        // Function to initialize all charts
        function initAllCharts() {
            initEnergyPerceptionChart();
            initCalibrationGapChart();
            initKnowledgeInteractionChart();
            initRelianceInteractionChart();
            initConfidenceChart();
            initCalibrationErrorChart(); 
            initKnowledgeModerationChart();
            initAILiteracyModerationChart();
            initDashboardCharts();
            createMethodsDiagram();
            createLLMInternalDiagram();
        }
        
        // Initialize the dashboard on page load
        window.onload = function() {
            initAllCharts();
        };
    </script>


</body></html>